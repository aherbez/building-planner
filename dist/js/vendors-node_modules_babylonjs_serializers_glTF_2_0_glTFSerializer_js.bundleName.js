"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_babylonjs_serializers_glTF_2_0_glTFSerializer_js"],{

/***/ "./node_modules/@babylonjs/serializers/exportUtils.js"
/*!************************************************************!*\
  !*** ./node_modules/@babylonjs/serializers/exportUtils.js ***!
  \************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConvertHandednessMatrix: () => (/* binding */ ConvertHandednessMatrix),\n/* harmony export */   IsNoopNode: () => (/* binding */ IsNoopNode)\n/* harmony export */ });\n/* harmony import */ var _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babylonjs/core/Maths/math.vector.js */ \"./node_modules/@babylonjs/core/Maths/math.vector.js\");\n/* harmony import */ var _babylonjs_core_Maths_math_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babylonjs/core/Maths/math.constants.js */ \"./node_modules/@babylonjs/core/Maths/math.constants.js\");\n/* harmony import */ var _babylonjs_core_Meshes_transformNode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babylonjs/core/Meshes/transformNode.js */ \"./node_modules/@babylonjs/core/Meshes/transformNode.js\");\n/* harmony import */ var _babylonjs_core_Meshes_abstractMesh_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babylonjs/core/Meshes/abstractMesh.js */ \"./node_modules/@babylonjs/core/Meshes/abstractMesh.js\");\n\n\n\n\n/**\n * Matrix that converts handedness on the X-axis. Used to convert from LH to RH and vice versa.\n * @internal\n */\nconst ConvertHandednessMatrix = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Matrix.Compose(new _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1, 1, 1), _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity(), _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero());\n/**\n * Checks if a node is a \"noop\" transform node, usually inserted by the glTF loader to correct handedness.\n * @internal\n */\nfunction IsNoopNode(node, useRightHandedSystem) {\n    if (!(node instanceof _babylonjs_core_Meshes_transformNode_js__WEBPACK_IMPORTED_MODULE_2__.TransformNode)) {\n        return false;\n    }\n    // Transform\n    if (useRightHandedSystem) {\n        const matrix = node.getWorldMatrix();\n        if (!matrix.equalsWithEpsilon(_babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Matrix.IdentityReadOnly, _babylonjs_core_Maths_math_constants_js__WEBPACK_IMPORTED_MODULE_1__.Epsilon)) {\n            return false;\n        }\n    }\n    else {\n        const matrix = node.getWorldMatrix().multiplyToRef(ConvertHandednessMatrix, _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Matrix[0]);\n        if (!matrix.equalsWithEpsilon(_babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Matrix.IdentityReadOnly, _babylonjs_core_Maths_math_constants_js__WEBPACK_IMPORTED_MODULE_1__.Epsilon)) {\n            return false;\n        }\n    }\n    // Geometry\n    if (node instanceof _babylonjs_core_Meshes_abstractMesh_js__WEBPACK_IMPORTED_MODULE_3__.AbstractMesh && node.geometry) {\n        return false;\n    }\n    return true;\n}\n//# sourceMappingURL=exportUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/serializers/exportUtils.js?\n}");

/***/ },

/***/ "./node_modules/@babylonjs/serializers/glTF/2.0/bufferManager.js"
/*!***********************************************************************!*\
  !*** ./node_modules/@babylonjs/serializers/glTF/2.0/bufferManager.js ***!
  \***********************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BufferManager: () => (/* binding */ BufferManager)\n/* harmony export */ });\n/* harmony import */ var _dataWriter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dataWriter.js */ \"./node_modules/@babylonjs/serializers/glTF/2.0/dataWriter.js\");\n\nfunction GetHighestByteAlignment(byteLength) {\n    if (byteLength % 4 === 0) {\n        return 4;\n    }\n    if (byteLength % 2 === 0) {\n        return 2;\n    }\n    return 1;\n}\n/**\n * Utility class to centralize the management of binary data, bufferViews, and the objects that reference them.\n * @internal\n */\nclass BufferManager {\n    constructor() {\n        /**\n         * Maps a bufferView to its data\n         */\n        this._bufferViewToData = new Map();\n        /**\n         * Maps a bufferView to glTF objects that reference it via a \"bufferView\" property (e.g. accessors, images)\n         */\n        this._bufferViewToProperties = new Map();\n        /**\n         * Maps an accessor to its bufferView\n         */\n        this._accessorToBufferView = new Map();\n    }\n    /**\n     * Generates a binary buffer from the stored bufferViews. Also populates the bufferViews list.\n     * @param bufferViews The list of bufferViews to be populated while writing the binary\n     * @returns The binary buffer\n     */\n    generateBinary(bufferViews) {\n        // Construct a DataWriter with the total byte length to prevent resizing\n        let totalByteLength = 0;\n        this._bufferViewToData.forEach((data) => {\n            totalByteLength += data.byteLength;\n        });\n        const dataWriter = new _dataWriter_js__WEBPACK_IMPORTED_MODULE_0__.DataWriter(totalByteLength);\n        // Order the bufferViews in descending order of their alignment requirements\n        const orderedBufferViews = Array.from(this._bufferViewToData.keys()).sort((a, b) => GetHighestByteAlignment(b.byteLength) - GetHighestByteAlignment(a.byteLength));\n        // Fill in the bufferViews list and missing bufferView index references while writing the binary\n        for (const bufferView of orderedBufferViews) {\n            bufferView.byteOffset = dataWriter.byteOffset;\n            bufferViews.push(bufferView);\n            const bufferViewIndex = bufferViews.length - 1;\n            const properties = this.getPropertiesWithBufferView(bufferView);\n            for (const object of properties) {\n                object.bufferView = bufferViewIndex;\n            }\n            dataWriter.writeTypedArray(this._bufferViewToData.get(bufferView));\n            this._bufferViewToData.delete(bufferView); // Try to free up memory ASAP\n        }\n        return dataWriter.getOutputData();\n    }\n    /**\n     * Creates a buffer view based on the supplied arguments\n     * @param data a TypedArray to create the bufferView for\n     * @param byteStride byte distance between consecutive elements\n     * @returns bufferView for glTF\n     */\n    createBufferView(data, byteStride) {\n        const bufferView = {\n            buffer: 0,\n            byteOffset: undefined, // byteOffset will be set later, when we write the binary and decide bufferView ordering\n            byteLength: data.byteLength,\n            byteStride: byteStride,\n        };\n        this._bufferViewToData.set(bufferView, data);\n        return bufferView;\n    }\n    /**\n     * Creates an accessor based on the supplied arguments and assigns it to the bufferView\n     * @param bufferView The glTF bufferView referenced by this accessor\n     * @param type The type of the accessor\n     * @param componentType The datatype of components in the attribute\n     * @param count The number of attributes referenced by this accessor\n     * @param byteOffset The offset relative to the start of the bufferView in bytes\n     * @param minMax Minimum and maximum value of each component in this attribute\n     * @param normalized Specifies whether integer data values are normalized before usage\n     * @returns accessor for glTF\n     */\n    createAccessor(bufferView, type, componentType, count, byteOffset, minMax, normalized) {\n        this._verifyBufferView(bufferView);\n        const accessor = {\n            bufferView: undefined, // bufferView will be set to a real index later, once we write the binary and decide bufferView ordering\n            componentType: componentType,\n            count: count,\n            type: type,\n            min: minMax?.min,\n            max: minMax?.max,\n            normalized: normalized,\n            byteOffset: byteOffset,\n        };\n        this.setBufferView(accessor, bufferView);\n        this._accessorToBufferView.set(accessor, bufferView);\n        return accessor;\n    }\n    /**\n     * Assigns a bufferView to a glTF object that references it\n     * @param object The glTF object\n     * @param bufferView The bufferView to assign\n     */\n    setBufferView(object, bufferView) {\n        this._verifyBufferView(bufferView);\n        const properties = this.getPropertiesWithBufferView(bufferView);\n        properties.push(object);\n    }\n    /**\n     * Removes buffer view from the binary data, as well as from all its known references\n     * @param bufferView the bufferView to remove\n     */\n    removeBufferView(bufferView) {\n        const properties = this.getPropertiesWithBufferView(bufferView);\n        for (const object of properties) {\n            if (object.bufferView !== undefined) {\n                delete object.bufferView;\n            }\n        }\n        this._bufferViewToData.delete(bufferView);\n        this._bufferViewToProperties.delete(bufferView);\n        this._accessorToBufferView.forEach((bv, accessor) => {\n            if (bv === bufferView) {\n                // Additionally, remove byteOffset from accessor referencing this bufferView\n                if (accessor.byteOffset !== undefined) {\n                    delete accessor.byteOffset;\n                }\n                this._accessorToBufferView.delete(accessor);\n            }\n        });\n    }\n    getBufferView(accessor) {\n        const bufferView = this._accessorToBufferView.get(accessor);\n        this._verifyBufferView(bufferView);\n        return bufferView;\n    }\n    getPropertiesWithBufferView(bufferView) {\n        this._verifyBufferView(bufferView);\n        this._bufferViewToProperties.set(bufferView, this._bufferViewToProperties.get(bufferView) ?? []);\n        return this._bufferViewToProperties.get(bufferView);\n    }\n    getData(bufferView) {\n        this._verifyBufferView(bufferView);\n        return this._bufferViewToData.get(bufferView);\n    }\n    _verifyBufferView(bufferView) {\n        if (bufferView === undefined || !this._bufferViewToData.has(bufferView)) {\n            throw new Error(`BufferView ${bufferView} not found in BufferManager.`);\n        }\n    }\n}\n//# sourceMappingURL=bufferManager.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/serializers/glTF/2.0/bufferManager.js?\n}");

/***/ },

/***/ "./node_modules/@babylonjs/serializers/glTF/2.0/dataWriter.js"
/*!********************************************************************!*\
  !*** ./node_modules/@babylonjs/serializers/glTF/2.0/dataWriter.js ***!
  \********************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataWriter: () => (/* binding */ DataWriter)\n/* harmony export */ });\nconst TypedArrayToWriteMethod = new Map([\n    [Int8Array, (d, b, v) => d.setInt8(b, v)],\n    [Uint8Array, (dv, bo, v) => dv.setUint8(bo, v)],\n    [Uint8ClampedArray, (dv, bo, v) => dv.setUint8(bo, v)],\n    [Int16Array, (dv, bo, v) => dv.setInt16(bo, v, true)],\n    [Uint16Array, (dv, bo, v) => dv.setUint16(bo, v, true)],\n    [Int32Array, (dv, bo, v) => dv.setInt32(bo, v, true)],\n    [Uint32Array, (dv, bo, v) => dv.setUint32(bo, v, true)],\n    [Float32Array, (dv, bo, v) => dv.setFloat32(bo, v, true)],\n    [Float64Array, (dv, bo, v) => dv.setFloat64(bo, v, true)],\n]);\n/** @internal */\nclass DataWriter {\n    writeTypedArray(value) {\n        this._checkGrowBuffer(value.byteLength);\n        const setMethod = TypedArrayToWriteMethod.get(value.constructor);\n        for (let i = 0; i < value.length; i++) {\n            setMethod(this._dataView, this._byteOffset, value[i]);\n            this._byteOffset += value.BYTES_PER_ELEMENT;\n        }\n    }\n    constructor(byteLength) {\n        this._data = new Uint8Array(byteLength);\n        this._dataView = new DataView(this._data.buffer);\n        this._byteOffset = 0;\n    }\n    get byteOffset() {\n        return this._byteOffset;\n    }\n    getOutputData() {\n        return new Uint8Array(this._data.buffer, 0, this._byteOffset);\n    }\n    writeUInt8(value) {\n        this._checkGrowBuffer(1);\n        this._dataView.setUint8(this._byteOffset, value);\n        this._byteOffset++;\n    }\n    writeInt8(value) {\n        this._checkGrowBuffer(1);\n        this._dataView.setInt8(this._byteOffset, value);\n        this._byteOffset++;\n    }\n    writeInt16(entry) {\n        this._checkGrowBuffer(2);\n        this._dataView.setInt16(this._byteOffset, entry, true);\n        this._byteOffset += 2;\n    }\n    writeUInt16(value) {\n        this._checkGrowBuffer(2);\n        this._dataView.setUint16(this._byteOffset, value, true);\n        this._byteOffset += 2;\n    }\n    writeInt32(entry) {\n        this._checkGrowBuffer(4);\n        this._dataView.setInt32(this._byteOffset, entry, true);\n        this._byteOffset += 4;\n    }\n    writeUInt32(value) {\n        this._checkGrowBuffer(4);\n        this._dataView.setUint32(this._byteOffset, value, true);\n        this._byteOffset += 4;\n    }\n    writeFloat32(value) {\n        this._checkGrowBuffer(4);\n        this._dataView.setFloat32(this._byteOffset, value, true);\n        this._byteOffset += 4;\n    }\n    writeFloat64(value) {\n        this._checkGrowBuffer(8);\n        this._dataView.setFloat64(this._byteOffset, value, true);\n        this._byteOffset += 8;\n    }\n    _checkGrowBuffer(byteLength) {\n        const newByteLength = this.byteOffset + byteLength;\n        if (newByteLength > this._data.byteLength) {\n            const newData = new Uint8Array(newByteLength * 2);\n            newData.set(this._data);\n            this._data = newData;\n            this._dataView = new DataView(this._data.buffer);\n        }\n    }\n}\n//# sourceMappingURL=dataWriter.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/serializers/glTF/2.0/dataWriter.js?\n}");

/***/ },

/***/ "./node_modules/@babylonjs/serializers/glTF/2.0/glTFAnimation.js"
/*!***********************************************************************!*\
  !*** ./node_modules/@babylonjs/serializers/glTF/2.0/glTFAnimation.js ***!
  \***********************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _GLTFAnimation: () => (/* binding */ _GLTFAnimation)\n/* harmony export */ });\n/* harmony import */ var _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babylonjs/core/Maths/math.vector.js */ \"./node_modules/@babylonjs/core/Maths/math.vector.js\");\n/* harmony import */ var _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babylonjs/core/Misc/tools.js */ \"./node_modules/@babylonjs/core/Misc/tools.js\");\n/* harmony import */ var _babylonjs_core_Animations_animation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babylonjs/core/Animations/animation.js */ \"./node_modules/@babylonjs/core/Animations/animation.js\");\n/* harmony import */ var _babylonjs_core_Meshes_transformNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babylonjs/core/Meshes/transformNode.js */ \"./node_modules/@babylonjs/core/Meshes/transformNode.js\");\n/* harmony import */ var _babylonjs_core_Morph_morphTarget_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babylonjs/core/Morph/morphTarget.js */ \"./node_modules/@babylonjs/core/Morph/morphTarget.js\");\n/* harmony import */ var _babylonjs_core_Meshes_mesh_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babylonjs/core/Meshes/mesh.js */ \"./node_modules/@babylonjs/core/Meshes/mesh.js\");\n/* harmony import */ var _babylonjs_core_Cameras_camera_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babylonjs/core/Cameras/camera.js */ \"./node_modules/@babylonjs/core/Cameras/camera.js\");\n/* harmony import */ var _babylonjs_core_Lights_light_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babylonjs/core/Lights/light.js */ \"./node_modules/@babylonjs/core/Lights/light.js\");\n/* harmony import */ var _glTFUtilities_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./glTFUtilities.js */ \"./node_modules/@babylonjs/serializers/glTF/2.0/glTFUtilities.js\");\n\n\n\n\n\n\n\n\n\n/**\n * @internal\n * Enum for handling in tangent and out tangent.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nvar _TangentType;\n(function (_TangentType) {\n    /**\n     * Specifies that input tangents are used.\n     */\n    _TangentType[_TangentType[\"INTANGENT\"] = 0] = \"INTANGENT\";\n    /**\n     * Specifies that output tangents are used.\n     */\n    _TangentType[_TangentType[\"OUTTANGENT\"] = 1] = \"OUTTANGENT\";\n})(_TangentType || (_TangentType = {}));\n/**\n * @internal\n * Utility class for generating glTF animation data from BabylonJS.\n */\nclass _GLTFAnimation {\n    /**\n     * Determine if a node is transformable - ie has properties it should be part of animation of transformation.\n     * @param babylonNode the node to test\n     * @returns true if can be animated, false otherwise. False if the parameter is null or undefined.\n     */\n    static _IsTransformable(babylonNode) {\n        return babylonNode && (babylonNode instanceof _babylonjs_core_Meshes_transformNode_js__WEBPACK_IMPORTED_MODULE_3__.TransformNode || babylonNode instanceof _babylonjs_core_Cameras_camera_js__WEBPACK_IMPORTED_MODULE_6__.Camera || babylonNode instanceof _babylonjs_core_Lights_light_js__WEBPACK_IMPORTED_MODULE_7__.Light);\n    }\n    /**\n     * @ignore\n     *\n     * Creates glTF channel animation from BabylonJS animation.\n     * @param babylonTransformNode - BabylonJS mesh.\n     * @param animation - animation.\n     * @param animationChannelTargetPath - The target animation channel.\n     * @param useQuaternion - Specifies if quaternions are used.\n     * @returns nullable IAnimationData\n     */\n    static _CreateNodeAnimation(babylonTransformNode, animation, animationChannelTargetPath, useQuaternion, animationSampleRate) {\n        if (this._IsTransformable(babylonTransformNode)) {\n            const inputs = [];\n            const outputs = [];\n            const keyFrames = animation.getKeys();\n            const minMaxKeyFrames = _GLTFAnimation._CalculateMinMaxKeyFrames(keyFrames);\n            const interpolationOrBake = _GLTFAnimation._DeduceInterpolation(keyFrames, animationChannelTargetPath, useQuaternion);\n            const interpolation = interpolationOrBake.interpolationType;\n            const shouldBakeAnimation = interpolationOrBake.shouldBakeAnimation;\n            if (shouldBakeAnimation) {\n                _GLTFAnimation._CreateBakedAnimation(babylonTransformNode, animation, animationChannelTargetPath, minMaxKeyFrames.min, minMaxKeyFrames.max, animation.framePerSecond, animationSampleRate, inputs, outputs, minMaxKeyFrames, useQuaternion);\n            }\n            else {\n                if (interpolation === \"LINEAR\" /* AnimationSamplerInterpolation.LINEAR */ || interpolation === \"STEP\" /* AnimationSamplerInterpolation.STEP */) {\n                    _GLTFAnimation._CreateLinearOrStepAnimation(babylonTransformNode, animation, animationChannelTargetPath, inputs, outputs, useQuaternion);\n                }\n                else if (interpolation === \"CUBICSPLINE\" /* AnimationSamplerInterpolation.CUBICSPLINE */) {\n                    _GLTFAnimation._CreateCubicSplineAnimation(babylonTransformNode, animation, animationChannelTargetPath, inputs, outputs, useQuaternion);\n                }\n                else {\n                    _GLTFAnimation._CreateBakedAnimation(babylonTransformNode, animation, animationChannelTargetPath, minMaxKeyFrames.min, minMaxKeyFrames.max, animation.framePerSecond, animationSampleRate, inputs, outputs, minMaxKeyFrames, useQuaternion);\n                }\n            }\n            if (inputs.length && outputs.length) {\n                const result = {\n                    inputs: inputs,\n                    outputs: outputs,\n                    samplerInterpolation: interpolation,\n                    inputsMin: shouldBakeAnimation ? minMaxKeyFrames.min : _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.FloatRound(minMaxKeyFrames.min / animation.framePerSecond),\n                    inputsMax: shouldBakeAnimation ? minMaxKeyFrames.max : _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.FloatRound(minMaxKeyFrames.max / animation.framePerSecond),\n                };\n                return result;\n            }\n        }\n        return null;\n    }\n    static _DeduceAnimationInfo(animation) {\n        let animationChannelTargetPath = null;\n        let dataAccessorType = \"VEC3\" /* AccessorType.VEC3 */;\n        let useQuaternion = false;\n        const property = animation.targetProperty.split(\".\");\n        switch (property[0]) {\n            case \"scaling\": {\n                animationChannelTargetPath = \"scale\" /* AnimationChannelTargetPath.SCALE */;\n                break;\n            }\n            case \"position\": {\n                animationChannelTargetPath = \"translation\" /* AnimationChannelTargetPath.TRANSLATION */;\n                break;\n            }\n            case \"rotation\": {\n                dataAccessorType = \"VEC4\" /* AccessorType.VEC4 */;\n                animationChannelTargetPath = \"rotation\" /* AnimationChannelTargetPath.ROTATION */;\n                break;\n            }\n            case \"rotationQuaternion\": {\n                dataAccessorType = \"VEC4\" /* AccessorType.VEC4 */;\n                useQuaternion = true;\n                animationChannelTargetPath = \"rotation\" /* AnimationChannelTargetPath.ROTATION */;\n                break;\n            }\n            case \"influence\": {\n                dataAccessorType = \"SCALAR\" /* AccessorType.SCALAR */;\n                animationChannelTargetPath = \"weights\" /* AnimationChannelTargetPath.WEIGHTS */;\n                break;\n            }\n            default: {\n                _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.Error(`Unsupported animatable property ${property[0]}`);\n            }\n        }\n        if (animationChannelTargetPath) {\n            return { animationChannelTargetPath: animationChannelTargetPath, dataAccessorType: dataAccessorType, useQuaternion: useQuaternion };\n        }\n        else {\n            _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.Error(\"animation channel target path and data accessor type could be deduced\");\n        }\n        return null;\n    }\n    /**\n     * @ignore\n     * Create node animations from the transform node animations\n     * @param babylonNode\n     * @param runtimeGLTFAnimation\n     * @param idleGLTFAnimations\n     * @param nodeMap\n     * @param nodes\n     * @param bufferManager\n     * @param bufferViews\n     * @param accessors\n     * @param animationSampleRate\n     */\n    static _CreateNodeAnimationFromNodeAnimations(babylonNode, runtimeGLTFAnimation, idleGLTFAnimations, nodeMap, nodes, bufferManager, bufferViews, accessors, animationSampleRate, useRightHanded, shouldExportAnimation) {\n        let glTFAnimation;\n        if (_GLTFAnimation._IsTransformable(babylonNode)) {\n            if (babylonNode.animations) {\n                for (const animation of babylonNode.animations) {\n                    if (shouldExportAnimation && !shouldExportAnimation(animation)) {\n                        continue;\n                    }\n                    const animationInfo = _GLTFAnimation._DeduceAnimationInfo(animation);\n                    if (animationInfo) {\n                        glTFAnimation = {\n                            name: animation.name,\n                            samplers: [],\n                            channels: [],\n                        };\n                        _GLTFAnimation._AddAnimation(`${animation.name}`, animation.hasRunningRuntimeAnimations ? runtimeGLTFAnimation : glTFAnimation, babylonNode, animation, animationInfo.dataAccessorType, animationInfo.animationChannelTargetPath, nodeMap, bufferManager, bufferViews, accessors, animationInfo.useQuaternion, animationSampleRate, useRightHanded);\n                        if (glTFAnimation.samplers.length && glTFAnimation.channels.length) {\n                            idleGLTFAnimations.push(glTFAnimation);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * @ignore\n     * Create individual morph animations from the mesh's morph target animation tracks\n     * @param babylonNode\n     * @param runtimeGLTFAnimation\n     * @param idleGLTFAnimations\n     * @param nodeMap\n     * @param nodes\n     * @param bufferManager\n     * @param bufferViews\n     * @param accessors\n     * @param animationSampleRate\n     */\n    static _CreateMorphTargetAnimationFromMorphTargetAnimations(babylonNode, runtimeGLTFAnimation, idleGLTFAnimations, nodeMap, nodes, bufferManager, bufferViews, accessors, animationSampleRate, useRightHanded, shouldExportAnimation) {\n        let glTFAnimation;\n        if (babylonNode instanceof _babylonjs_core_Meshes_mesh_js__WEBPACK_IMPORTED_MODULE_5__.Mesh) {\n            const morphTargetManager = babylonNode.morphTargetManager;\n            if (morphTargetManager) {\n                for (let i = 0; i < morphTargetManager.numTargets; ++i) {\n                    const morphTarget = morphTargetManager.getTarget(i);\n                    for (const animation of morphTarget.animations) {\n                        if (shouldExportAnimation && !shouldExportAnimation(animation)) {\n                            continue;\n                        }\n                        const combinedAnimation = new _babylonjs_core_Animations_animation_js__WEBPACK_IMPORTED_MODULE_2__.Animation(`${animation.name}`, \"influence\", animation.framePerSecond, animation.dataType, animation.loopMode, animation.enableBlending);\n                        const combinedAnimationKeys = [];\n                        const animationKeys = animation.getKeys();\n                        for (let j = 0; j < animationKeys.length; ++j) {\n                            const animationKey = animationKeys[j];\n                            for (let k = 0; k < morphTargetManager.numTargets; ++k) {\n                                if (k == i) {\n                                    combinedAnimationKeys.push(animationKey);\n                                }\n                                else {\n                                    combinedAnimationKeys.push({ frame: animationKey.frame, value: 0 });\n                                }\n                            }\n                        }\n                        combinedAnimation.setKeys(combinedAnimationKeys, true);\n                        const animationInfo = _GLTFAnimation._DeduceAnimationInfo(combinedAnimation);\n                        if (animationInfo) {\n                            glTFAnimation = {\n                                name: combinedAnimation.name,\n                                samplers: [],\n                                channels: [],\n                            };\n                            _GLTFAnimation._AddAnimation(animation.name, animation.hasRunningRuntimeAnimations ? runtimeGLTFAnimation : glTFAnimation, babylonNode, combinedAnimation, animationInfo.dataAccessorType, animationInfo.animationChannelTargetPath, nodeMap, bufferManager, bufferViews, accessors, animationInfo.useQuaternion, animationSampleRate, useRightHanded, morphTargetManager.numTargets);\n                            if (glTFAnimation.samplers.length && glTFAnimation.channels.length) {\n                                idleGLTFAnimations.push(glTFAnimation);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * @internal\n     * Create node and morph animations from the animation groups\n     * @param babylonScene\n     * @param glTFAnimations\n     * @param nodeMap\n     * @param nodes\n     * @param bufferManager\n     * @param bufferViews\n     * @param accessors\n     * @param animationSampleRate\n     */\n    static _CreateNodeAndMorphAnimationFromAnimationGroups(babylonScene, glTFAnimations, nodeMap, bufferManager, bufferViews, accessors, animationSampleRate, leftHandedNodes, shouldExportAnimation) {\n        let glTFAnimation;\n        if (babylonScene.animationGroups) {\n            const animationGroups = babylonScene.animationGroups;\n            for (const animationGroup of animationGroups) {\n                const morphAnimations = new Map();\n                const sampleAnimations = new Map();\n                const morphAnimationMeshes = new Set();\n                const animationGroupFrameDiff = animationGroup.to - animationGroup.from;\n                glTFAnimation = {\n                    name: animationGroup.name,\n                    channels: [],\n                    samplers: [],\n                };\n                for (let i = 0; i < animationGroup.targetedAnimations.length; ++i) {\n                    const targetAnimation = animationGroup.targetedAnimations[i];\n                    const target = targetAnimation.target;\n                    const animation = targetAnimation.animation;\n                    if (shouldExportAnimation && !shouldExportAnimation(animation)) {\n                        continue;\n                    }\n                    const convertToRightHanded = leftHandedNodes.has(target);\n                    if (this._IsTransformable(target) || (target.length === 1 && this._IsTransformable(target[0]))) {\n                        const animationInfo = _GLTFAnimation._DeduceAnimationInfo(targetAnimation.animation);\n                        if (animationInfo) {\n                            const babylonTransformNode = this._IsTransformable(target) ? target : this._IsTransformable(target[0]) ? target[0] : null;\n                            if (babylonTransformNode) {\n                                _GLTFAnimation._AddAnimation(`${animation.name}`, glTFAnimation, babylonTransformNode, animation, animationInfo.dataAccessorType, animationInfo.animationChannelTargetPath, nodeMap, bufferManager, bufferViews, accessors, animationInfo.useQuaternion, animationSampleRate, convertToRightHanded);\n                            }\n                        }\n                    }\n                    else if (target instanceof _babylonjs_core_Morph_morphTarget_js__WEBPACK_IMPORTED_MODULE_4__.MorphTarget || (target.length === 1 && target[0] instanceof _babylonjs_core_Morph_morphTarget_js__WEBPACK_IMPORTED_MODULE_4__.MorphTarget)) {\n                        const animationInfo = _GLTFAnimation._DeduceAnimationInfo(targetAnimation.animation);\n                        if (animationInfo) {\n                            const babylonMorphTarget = target instanceof _babylonjs_core_Morph_morphTarget_js__WEBPACK_IMPORTED_MODULE_4__.MorphTarget ? target : target[0];\n                            if (babylonMorphTarget) {\n                                const babylonMorphTargetManager = babylonScene.morphTargetManagers.find((morphTargetManager) => {\n                                    for (let j = 0; j < morphTargetManager.numTargets; ++j) {\n                                        if (morphTargetManager.getTarget(j) === babylonMorphTarget) {\n                                            return true;\n                                        }\n                                    }\n                                    return false;\n                                });\n                                if (babylonMorphTargetManager) {\n                                    const babylonMesh = babylonScene.meshes.find((mesh) => {\n                                        return mesh.morphTargetManager === babylonMorphTargetManager;\n                                    });\n                                    if (babylonMesh) {\n                                        if (!morphAnimations.has(babylonMesh)) {\n                                            morphAnimations.set(babylonMesh, new Map());\n                                        }\n                                        morphAnimations.get(babylonMesh)?.set(babylonMorphTarget, animation);\n                                        morphAnimationMeshes.add(babylonMesh);\n                                        sampleAnimations.set(babylonMesh, animation);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    else {\n                        // this is the place for the KHR_animation_pointer.\n                    }\n                }\n                morphAnimationMeshes.forEach((mesh) => {\n                    const morphTargetManager = mesh.morphTargetManager;\n                    let combinedAnimationGroup = null;\n                    const animationKeys = [];\n                    const sampleAnimation = sampleAnimations.get(mesh);\n                    const sampleAnimationKeys = sampleAnimation.getKeys();\n                    const numAnimationKeys = sampleAnimationKeys.length;\n                    /*\n                        Due to how glTF expects morph target animation data to be formatted, we need to rearrange the individual morph target animation tracks,\n                        such that we have a single animation, where a given keyframe input value has successive output values for each morph target belonging to the manager.\n                        See: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n\n                        We do this via constructing a new Animation track, and interleaving the frames of each morph target animation track in the current Animation Group\n                        We reuse the Babylon Animation data structure for ease of handling export of cubic spline animation keys, and to reuse the\n                        existing _GLTFAnimation.AddAnimation codepath with minimal modification, however the constructed Babylon Animation is NOT intended for use in-engine.\n                    */\n                    for (let i = 0; i < numAnimationKeys; ++i) {\n                        for (let j = 0; j < morphTargetManager.numTargets; ++j) {\n                            const morphTarget = morphTargetManager.getTarget(j);\n                            const animationsByMorphTarget = morphAnimations.get(mesh);\n                            if (animationsByMorphTarget) {\n                                const morphTargetAnimation = animationsByMorphTarget.get(morphTarget);\n                                if (morphTargetAnimation) {\n                                    if (!combinedAnimationGroup) {\n                                        combinedAnimationGroup = new _babylonjs_core_Animations_animation_js__WEBPACK_IMPORTED_MODULE_2__.Animation(`${animationGroup.name}_${mesh.name}_MorphWeightAnimation`, \"influence\", morphTargetAnimation.framePerSecond, _babylonjs_core_Animations_animation_js__WEBPACK_IMPORTED_MODULE_2__.Animation.ANIMATIONTYPE_FLOAT, morphTargetAnimation.loopMode, morphTargetAnimation.enableBlending);\n                                    }\n                                    animationKeys.push(morphTargetAnimation.getKeys()[i]);\n                                }\n                                else {\n                                    animationKeys.push({\n                                        frame: animationGroup.from + (animationGroupFrameDiff / numAnimationKeys) * i,\n                                        value: morphTarget.influence,\n                                        inTangent: sampleAnimationKeys[0].inTangent ? 0 : undefined,\n                                        outTangent: sampleAnimationKeys[0].outTangent ? 0 : undefined,\n                                    });\n                                }\n                            }\n                        }\n                    }\n                    combinedAnimationGroup.setKeys(animationKeys, true);\n                    const animationInfo = _GLTFAnimation._DeduceAnimationInfo(combinedAnimationGroup);\n                    if (animationInfo) {\n                        _GLTFAnimation._AddAnimation(`${animationGroup.name}_${mesh.name}_MorphWeightAnimation`, glTFAnimation, mesh, combinedAnimationGroup, animationInfo.dataAccessorType, animationInfo.animationChannelTargetPath, nodeMap, bufferManager, bufferViews, accessors, animationInfo.useQuaternion, animationSampleRate, false, morphTargetManager?.numTargets);\n                    }\n                });\n                if (glTFAnimation.channels.length && glTFAnimation.samplers.length) {\n                    glTFAnimations.push(glTFAnimation);\n                }\n            }\n        }\n    }\n    static _AddAnimation(name, glTFAnimation, babylonTransformNode, animation, dataAccessorType, animationChannelTargetPath, nodeMap, bufferManager, bufferViews, accessors, useQuaternion, animationSampleRate, convertToRightHanded, morphAnimationChannels) {\n        const animationData = _GLTFAnimation._CreateNodeAnimation(babylonTransformNode, animation, animationChannelTargetPath, useQuaternion, animationSampleRate);\n        let bufferView;\n        let accessor;\n        let keyframeAccessorIndex;\n        let dataAccessorIndex;\n        let animationSampler;\n        let animationChannel;\n        if (animationData) {\n            /*\n             * Now that we have the glTF converted morph target animation data,\n             * we can remove redundant input data so that we have n input frames,\n             * and morphAnimationChannels * n output frames\n             */\n            if (morphAnimationChannels) {\n                let index = 0;\n                let currentInput = 0;\n                const newInputs = [];\n                while (animationData.inputs.length > 0) {\n                    currentInput = animationData.inputs.shift();\n                    if (index % morphAnimationChannels == 0) {\n                        newInputs.push(currentInput);\n                    }\n                    index++;\n                }\n                animationData.inputs = newInputs;\n            }\n            const nodeIndex = nodeMap.get(babylonTransformNode);\n            // Create buffer view and accessor for key frames.\n            const inputData = new Float32Array(animationData.inputs);\n            bufferView = bufferManager.createBufferView(inputData);\n            accessor = bufferManager.createAccessor(bufferView, \"SCALAR\" /* AccessorType.SCALAR */, 5126 /* AccessorComponentType.FLOAT */, animationData.inputs.length, undefined, {\n                min: [animationData.inputsMin],\n                max: [animationData.inputsMax],\n            });\n            accessors.push(accessor);\n            keyframeAccessorIndex = accessors.length - 1;\n            // Perform conversions on keyed values while also building their buffer.\n            const rotationQuaternion = new _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n            const eulerVec3 = new _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            const position = new _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            const isCamera = babylonTransformNode instanceof _babylonjs_core_Cameras_camera_js__WEBPACK_IMPORTED_MODULE_6__.Camera;\n            const elementCount = (0,_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_8__.GetAccessorElementCount)(dataAccessorType);\n            const outputData = new Float32Array(animationData.outputs.length * elementCount);\n            animationData.outputs.forEach(function (output, index) {\n                let outputToWrite = output;\n                switch (animationChannelTargetPath) {\n                    case \"translation\" /* AnimationChannelTargetPath.TRANSLATION */:\n                        if (convertToRightHanded) {\n                            _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(output, 0, position);\n                            (0,_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_8__.ConvertToRightHandedPosition)(position);\n                            position.toArray(outputToWrite);\n                        }\n                        break;\n                    case \"rotation\" /* AnimationChannelTargetPath.ROTATION */:\n                        if (output.length === 4) {\n                            _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Quaternion.FromArrayToRef(output, 0, rotationQuaternion);\n                        }\n                        else {\n                            outputToWrite = new Array(4); // Will need 4, not 3, for a quaternion\n                            _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(output, 0, eulerVec3);\n                            _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Quaternion.FromEulerVectorToRef(eulerVec3, rotationQuaternion);\n                        }\n                        if (convertToRightHanded) {\n                            (0,_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_8__.ConvertToRightHandedRotation)(rotationQuaternion);\n                            if (isCamera) {\n                                (0,_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_8__.Rotate180Y)(rotationQuaternion);\n                            }\n                        }\n                        rotationQuaternion.toArray(outputToWrite);\n                        break;\n                }\n                outputData.set(outputToWrite, index * elementCount);\n            });\n            // Create buffer view and accessor for keyed values.\n            bufferView = bufferManager.createBufferView(outputData);\n            accessor = bufferManager.createAccessor(bufferView, dataAccessorType, 5126 /* AccessorComponentType.FLOAT */, animationData.outputs.length);\n            accessors.push(accessor);\n            dataAccessorIndex = accessors.length - 1;\n            // create sampler\n            animationSampler = {\n                interpolation: animationData.samplerInterpolation,\n                input: keyframeAccessorIndex,\n                output: dataAccessorIndex,\n            };\n            glTFAnimation.samplers.push(animationSampler);\n            // create channel\n            animationChannel = {\n                sampler: glTFAnimation.samplers.length - 1,\n                target: {\n                    node: nodeIndex,\n                    path: animationChannelTargetPath,\n                },\n            };\n            glTFAnimation.channels.push(animationChannel);\n        }\n    }\n    /**\n     * Create a baked animation\n     * @param babylonTransformNode BabylonJS mesh\n     * @param animation BabylonJS animation corresponding to the BabylonJS mesh\n     * @param animationChannelTargetPath animation target channel\n     * @param minFrame minimum animation frame\n     * @param maxFrame maximum animation frame\n     * @param fps frames per second of the animation\n     * @param sampleRate\n     * @param inputs input key frames of the animation\n     * @param outputs output key frame data of the animation\n     * @param minMaxFrames\n     * @param minMaxFrames.min\n     * @param minMaxFrames.max\n     * @param useQuaternion specifies if quaternions should be used\n     */\n    static _CreateBakedAnimation(babylonTransformNode, animation, animationChannelTargetPath, minFrame, maxFrame, fps, sampleRate, inputs, outputs, minMaxFrames, useQuaternion) {\n        let value;\n        const quaternionCache = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity();\n        let previousTime = null;\n        let time;\n        let maxUsedFrame = null;\n        let currKeyFrame = null;\n        let nextKeyFrame = null;\n        let prevKeyFrame = null;\n        let endFrame = null;\n        minMaxFrames.min = _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.FloatRound(minFrame / fps);\n        const keyFrames = animation.getKeys();\n        for (let i = 0, length = keyFrames.length; i < length; ++i) {\n            endFrame = null;\n            currKeyFrame = keyFrames[i];\n            if (i + 1 < length) {\n                nextKeyFrame = keyFrames[i + 1];\n                if ((currKeyFrame.value.equals && currKeyFrame.value.equals(nextKeyFrame.value)) || currKeyFrame.value === nextKeyFrame.value) {\n                    if (i === 0) {\n                        // set the first frame to itself\n                        endFrame = currKeyFrame.frame;\n                    }\n                    else {\n                        continue;\n                    }\n                }\n                else {\n                    endFrame = nextKeyFrame.frame;\n                }\n            }\n            else {\n                // at the last key frame\n                prevKeyFrame = keyFrames[i - 1];\n                if ((currKeyFrame.value.equals && currKeyFrame.value.equals(prevKeyFrame.value)) || currKeyFrame.value === prevKeyFrame.value) {\n                    continue;\n                }\n                else {\n                    endFrame = maxFrame;\n                }\n            }\n            if (endFrame) {\n                for (let f = currKeyFrame.frame; f <= endFrame; f += sampleRate) {\n                    time = _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.FloatRound(f / fps);\n                    if (time === previousTime) {\n                        continue;\n                    }\n                    previousTime = time;\n                    maxUsedFrame = time;\n                    const state = {\n                        key: 0,\n                        repeatCount: 0,\n                        loopMode: animation.loopMode,\n                    };\n                    value = animation._interpolate(f, state);\n                    _GLTFAnimation._SetInterpolatedValue(babylonTransformNode, value, time, animation, animationChannelTargetPath, quaternionCache, inputs, outputs, useQuaternion);\n                }\n            }\n        }\n        if (maxUsedFrame) {\n            minMaxFrames.max = maxUsedFrame;\n        }\n    }\n    static _ConvertFactorToVector3OrQuaternion(factor, babylonTransformNode, animation, animationChannelTargetPath, useQuaternion) {\n        const basePositionRotationOrScale = _GLTFAnimation._GetBasePositionRotationOrScale(babylonTransformNode, animationChannelTargetPath, useQuaternion);\n        // handles single component x, y, z or w component animation by using a base property and animating over a component.\n        const property = animation.targetProperty.split(\".\");\n        const componentName = property ? property[1] : \"\"; // x, y, z, or w component\n        const value = useQuaternion ? _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Quaternion.FromArray(basePositionRotationOrScale).normalize() : _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArray(basePositionRotationOrScale);\n        switch (componentName) {\n            case \"x\":\n            case \"y\":\n            case \"z\": {\n                value[componentName] = factor;\n                break;\n            }\n            case \"w\": {\n                value.w = factor;\n                break;\n            }\n            default: {\n                _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.Error(`glTFAnimation: Unsupported component name \"${componentName}\"!`);\n            }\n        }\n        return value;\n    }\n    static _SetInterpolatedValue(babylonTransformNode, value, time, animation, animationChannelTargetPath, quaternionCache, inputs, outputs, useQuaternion) {\n        let cacheValue;\n        inputs.push(time);\n        if (animationChannelTargetPath === \"weights\" /* AnimationChannelTargetPath.WEIGHTS */) {\n            outputs.push([value]);\n            return;\n        }\n        if (animation.dataType === _babylonjs_core_Animations_animation_js__WEBPACK_IMPORTED_MODULE_2__.Animation.ANIMATIONTYPE_FLOAT) {\n            value = this._ConvertFactorToVector3OrQuaternion(value, babylonTransformNode, animation, animationChannelTargetPath, useQuaternion);\n        }\n        if (animationChannelTargetPath === \"rotation\" /* AnimationChannelTargetPath.ROTATION */) {\n            if (useQuaternion) {\n                quaternionCache = value;\n            }\n            else {\n                cacheValue = value;\n                _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Quaternion.RotationYawPitchRollToRef(cacheValue.y, cacheValue.x, cacheValue.z, quaternionCache);\n            }\n            outputs.push(quaternionCache.asArray());\n        }\n        else {\n            // scaling and position animation\n            cacheValue = value;\n            outputs.push(cacheValue.asArray());\n        }\n    }\n    /**\n     * Creates linear animation from the animation key frames\n     * @param babylonTransformNode BabylonJS mesh\n     * @param animation BabylonJS animation\n     * @param animationChannelTargetPath The target animation channel\n     * @param inputs Array to store the key frame times\n     * @param outputs Array to store the key frame data\n     * @param useQuaternion Specifies if quaternions are used in the animation\n     */\n    static _CreateLinearOrStepAnimation(babylonTransformNode, animation, animationChannelTargetPath, inputs, outputs, useQuaternion) {\n        for (const keyFrame of animation.getKeys()) {\n            inputs.push(keyFrame.frame / animation.framePerSecond); // keyframes in seconds.\n            _GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, useQuaternion);\n        }\n    }\n    /**\n     * Creates cubic spline animation from the animation key frames\n     * @param babylonTransformNode BabylonJS mesh\n     * @param animation BabylonJS animation\n     * @param animationChannelTargetPath The target animation channel\n     * @param inputs Array to store the key frame times\n     * @param outputs Array to store the key frame data\n     * @param useQuaternion Specifies if quaternions are used in the animation\n     */\n    static _CreateCubicSplineAnimation(babylonTransformNode, animation, animationChannelTargetPath, inputs, outputs, useQuaternion) {\n        animation.getKeys().forEach(function (keyFrame) {\n            inputs.push(keyFrame.frame / animation.framePerSecond); // keyframes in seconds.\n            _GLTFAnimation._AddSplineTangent(_TangentType.INTANGENT, outputs, animationChannelTargetPath, \"CUBICSPLINE\" /* AnimationSamplerInterpolation.CUBICSPLINE */, keyFrame, useQuaternion);\n            _GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, useQuaternion);\n            _GLTFAnimation._AddSplineTangent(_TangentType.OUTTANGENT, outputs, animationChannelTargetPath, \"CUBICSPLINE\" /* AnimationSamplerInterpolation.CUBICSPLINE */, keyFrame, useQuaternion);\n        });\n    }\n    static _GetBasePositionRotationOrScale(babylonTransformNode, animationChannelTargetPath, useQuaternion) {\n        let basePositionRotationOrScale;\n        if (animationChannelTargetPath === \"rotation\" /* AnimationChannelTargetPath.ROTATION */) {\n            if (useQuaternion) {\n                const q = babylonTransformNode.rotationQuaternion;\n                basePositionRotationOrScale = (q ?? _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity()).asArray();\n            }\n            else {\n                const r = babylonTransformNode.rotation;\n                basePositionRotationOrScale = (r ?? _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero()).asArray();\n            }\n        }\n        else if (animationChannelTargetPath === \"translation\" /* AnimationChannelTargetPath.TRANSLATION */) {\n            const p = babylonTransformNode.position;\n            basePositionRotationOrScale = (p ?? _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero()).asArray();\n        }\n        else {\n            // scale\n            const s = babylonTransformNode.scaling;\n            basePositionRotationOrScale = (s ?? _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.One()).asArray();\n        }\n        return basePositionRotationOrScale;\n    }\n    /**\n     * Adds a key frame value\n     * @param keyFrame\n     * @param animation\n     * @param outputs\n     * @param animationChannelTargetPath\n     * @param babylonTransformNode\n     * @param useQuaternion\n     */\n    static _AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, useQuaternion) {\n        let newPositionRotationOrScale;\n        const animationType = animation.dataType;\n        if (animationType === _babylonjs_core_Animations_animation_js__WEBPACK_IMPORTED_MODULE_2__.Animation.ANIMATIONTYPE_VECTOR3) {\n            let value = keyFrame.value.asArray();\n            if (animationChannelTargetPath === \"rotation\" /* AnimationChannelTargetPath.ROTATION */) {\n                const array = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArray(value);\n                const rotationQuaternion = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Quaternion.RotationYawPitchRoll(array.y, array.x, array.z);\n                value = rotationQuaternion.asArray();\n            }\n            outputs.push(value); // scale  vector.\n        }\n        else if (animationType === _babylonjs_core_Animations_animation_js__WEBPACK_IMPORTED_MODULE_2__.Animation.ANIMATIONTYPE_FLOAT) {\n            if (animationChannelTargetPath === \"weights\" /* AnimationChannelTargetPath.WEIGHTS */) {\n                outputs.push([keyFrame.value]);\n            }\n            else {\n                // handles single component x, y, z or w component animation by using a base property and animating over a component.\n                newPositionRotationOrScale = this._ConvertFactorToVector3OrQuaternion(keyFrame.value, babylonTransformNode, animation, animationChannelTargetPath, useQuaternion);\n                if (newPositionRotationOrScale) {\n                    if (animationChannelTargetPath === \"rotation\" /* AnimationChannelTargetPath.ROTATION */) {\n                        const posRotScale = useQuaternion\n                            ? newPositionRotationOrScale\n                            : _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Quaternion.RotationYawPitchRoll(newPositionRotationOrScale.y, newPositionRotationOrScale.x, newPositionRotationOrScale.z).normalize();\n                        outputs.push(posRotScale.asArray());\n                    }\n                    outputs.push(newPositionRotationOrScale.asArray());\n                }\n            }\n        }\n        else if (animationType === _babylonjs_core_Animations_animation_js__WEBPACK_IMPORTED_MODULE_2__.Animation.ANIMATIONTYPE_QUATERNION) {\n            outputs.push(keyFrame.value.normalize().asArray());\n        }\n        else {\n            _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.Error(\"glTFAnimation: Unsupported key frame values for animation!\");\n        }\n    }\n    /**\n     * @internal\n     * Determine the interpolation based on the key frames\n     * @param keyFrames\n     * @param animationChannelTargetPath\n     * @param useQuaternion\n     */\n    static _DeduceInterpolation(keyFrames, animationChannelTargetPath, useQuaternion) {\n        let interpolationType;\n        let shouldBakeAnimation = false;\n        let key;\n        if (animationChannelTargetPath === \"rotation\" /* AnimationChannelTargetPath.ROTATION */ && !useQuaternion) {\n            return { interpolationType: \"LINEAR\" /* AnimationSamplerInterpolation.LINEAR */, shouldBakeAnimation: true };\n        }\n        for (let i = 0, length = keyFrames.length; i < length; ++i) {\n            key = keyFrames[i];\n            if (key.inTangent || key.outTangent) {\n                if (interpolationType) {\n                    if (interpolationType !== \"CUBICSPLINE\" /* AnimationSamplerInterpolation.CUBICSPLINE */) {\n                        interpolationType = \"LINEAR\" /* AnimationSamplerInterpolation.LINEAR */;\n                        shouldBakeAnimation = true;\n                        break;\n                    }\n                }\n                else {\n                    interpolationType = \"CUBICSPLINE\" /* AnimationSamplerInterpolation.CUBICSPLINE */;\n                }\n            }\n            else {\n                if (interpolationType) {\n                    if (interpolationType === \"CUBICSPLINE\" /* AnimationSamplerInterpolation.CUBICSPLINE */ ||\n                        (key.interpolation && key.interpolation === 1 /* AnimationKeyInterpolation.STEP */ && interpolationType !== \"STEP\" /* AnimationSamplerInterpolation.STEP */)) {\n                        interpolationType = \"LINEAR\" /* AnimationSamplerInterpolation.LINEAR */;\n                        shouldBakeAnimation = true;\n                        break;\n                    }\n                }\n                else {\n                    if (key.interpolation && key.interpolation === 1 /* AnimationKeyInterpolation.STEP */) {\n                        interpolationType = \"STEP\" /* AnimationSamplerInterpolation.STEP */;\n                    }\n                    else {\n                        interpolationType = \"LINEAR\" /* AnimationSamplerInterpolation.LINEAR */;\n                    }\n                }\n            }\n        }\n        if (!interpolationType) {\n            interpolationType = \"LINEAR\" /* AnimationSamplerInterpolation.LINEAR */;\n        }\n        return { interpolationType: interpolationType, shouldBakeAnimation: shouldBakeAnimation };\n    }\n    /**\n     * Adds an input tangent or output tangent to the output data\n     * If an input tangent or output tangent is missing, it uses the zero vector or zero quaternion\n     * @param tangentType Specifies which type of tangent to handle (inTangent or outTangent)\n     * @param outputs The animation data by keyframe\n     * @param animationChannelTargetPath The target animation channel\n     * @param interpolation The interpolation type\n     * @param keyFrame The key frame with the animation data\n     * @param useQuaternion Specifies if quaternions are used\n     */\n    static _AddSplineTangent(tangentType, outputs, animationChannelTargetPath, interpolation, keyFrame, useQuaternion) {\n        let tangent;\n        const tangentValue = tangentType === _TangentType.INTANGENT ? keyFrame.inTangent : keyFrame.outTangent;\n        if (interpolation === \"CUBICSPLINE\" /* AnimationSamplerInterpolation.CUBICSPLINE */) {\n            if (animationChannelTargetPath === \"rotation\" /* AnimationChannelTargetPath.ROTATION */) {\n                if (tangentValue) {\n                    if (useQuaternion) {\n                        tangent = tangentValue.asArray();\n                    }\n                    else {\n                        const array = tangentValue;\n                        tangent = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Quaternion.RotationYawPitchRoll(array.y, array.x, array.z).asArray();\n                    }\n                }\n                else {\n                    tangent = [0, 0, 0, 0];\n                }\n            }\n            else if (animationChannelTargetPath === \"weights\" /* AnimationChannelTargetPath.WEIGHTS */) {\n                if (tangentValue) {\n                    tangent = [tangentValue];\n                }\n                else {\n                    tangent = [0];\n                }\n            }\n            else {\n                if (tangentValue) {\n                    tangent = tangentValue.asArray();\n                }\n                else {\n                    tangent = [0, 0, 0];\n                }\n            }\n            outputs.push(tangent);\n        }\n    }\n    /**\n     * Get the minimum and maximum key frames' frame values\n     * @param keyFrames animation key frames\n     * @returns the minimum and maximum key frame value\n     */\n    static _CalculateMinMaxKeyFrames(keyFrames) {\n        let min = Infinity;\n        let max = -Infinity;\n        keyFrames.forEach(function (keyFrame) {\n            min = Math.min(min, keyFrame.frame);\n            max = Math.max(max, keyFrame.frame);\n        });\n        return { min: min, max: max };\n    }\n}\n//# sourceMappingURL=glTFAnimation.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/serializers/glTF/2.0/glTFAnimation.js?\n}");

/***/ },

/***/ "./node_modules/@babylonjs/serializers/glTF/2.0/glTFData.js"
/*!******************************************************************!*\
  !*** ./node_modules/@babylonjs/serializers/glTF/2.0/glTFData.js ***!
  \******************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLTFData: () => (/* binding */ GLTFData)\n/* harmony export */ });\n/* harmony import */ var _babylonjs_core_Misc_fileTools_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babylonjs/core/Misc/fileTools.js */ \"./node_modules/@babylonjs/core/Misc/fileTools.js\");\n/* harmony import */ var _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babylonjs/core/Misc/tools.js */ \"./node_modules/@babylonjs/core/Misc/tools.js\");\n\n\n/**\n * Class for holding and downloading glTF file data\n */\nclass GLTFData {\n    constructor() {\n        /**\n         * Object which contains the file name as the key and its data as the value\n         */\n        this.files = {};\n    }\n    /**\n     * @deprecated Use files instead\n     */\n    get glTFFiles() {\n        return this.files;\n    }\n    /**\n     * Downloads the glTF data as files based on their names and data\n     */\n    downloadFiles() {\n        for (const key in this.files) {\n            const value = this.files[key];\n            const blob = new Blob([value], { type: (0,_babylonjs_core_Misc_fileTools_js__WEBPACK_IMPORTED_MODULE_0__.GetMimeType)(key) });\n            _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.Download(blob, key);\n        }\n    }\n}\n//# sourceMappingURL=glTFData.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/serializers/glTF/2.0/glTFData.js?\n}");

/***/ },

/***/ "./node_modules/@babylonjs/serializers/glTF/2.0/glTFExporter.js"
/*!**********************************************************************!*\
  !*** ./node_modules/@babylonjs/serializers/glTF/2.0/glTFExporter.js ***!
  \**********************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLTFExporter: () => (/* binding */ GLTFExporter)\n/* harmony export */ });\n/* harmony import */ var _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babylonjs/core/Maths/math.vector.js */ \"./node_modules/@babylonjs/core/Maths/math.vector.js\");\n/* harmony import */ var _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babylonjs/core/Misc/tools.js */ \"./node_modules/@babylonjs/core/Misc/tools.js\");\n/* harmony import */ var _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babylonjs/core/Buffers/buffer.js */ \"./node_modules/@babylonjs/core/Buffers/buffer.js\");\n/* harmony import */ var _babylonjs_core_Meshes_transformNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babylonjs/core/Meshes/transformNode.js */ \"./node_modules/@babylonjs/core/Meshes/transformNode.js\");\n/* harmony import */ var _babylonjs_core_Meshes_abstractMesh_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babylonjs/core/Meshes/abstractMesh.js */ \"./node_modules/@babylonjs/core/Meshes/abstractMesh.js\");\n/* harmony import */ var _babylonjs_core_Meshes_instancedMesh_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babylonjs/core/Meshes/instancedMesh.js */ \"./node_modules/@babylonjs/core/Meshes/instancedMesh.js\");\n/* harmony import */ var _babylonjs_core_Materials_material_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babylonjs/core/Materials/material.js */ \"./node_modules/@babylonjs/core/Materials/material.js\");\n/* harmony import */ var _babylonjs_core_Engines_engine_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babylonjs/core/Engines/engine.js */ \"./node_modules/@babylonjs/core/Engines/engine.js\");\n/* harmony import */ var _babylonjs_core_Engines_engineStore_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @babylonjs/core/Engines/engineStore.js */ \"./node_modules/@babylonjs/core/Engines/engineStore.js\");\n/* harmony import */ var _glTFMaterialExporter_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./glTFMaterialExporter.js */ \"./node_modules/@babylonjs/serializers/glTF/2.0/glTFMaterialExporter.js\");\n/* harmony import */ var _glTFData_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./glTFData.js */ \"./node_modules/@babylonjs/serializers/glTF/2.0/glTFData.js\");\n/* harmony import */ var _glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./glTFUtilities.js */ \"./node_modules/@babylonjs/serializers/glTF/2.0/glTFUtilities.js\");\n/* harmony import */ var _exportUtils_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../exportUtils.js */ \"./node_modules/@babylonjs/serializers/exportUtils.js\");\n/* harmony import */ var _bufferManager_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./bufferManager.js */ \"./node_modules/@babylonjs/serializers/glTF/2.0/bufferManager.js\");\n/* harmony import */ var _babylonjs_core_Cameras_camera_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @babylonjs/core/Cameras/camera.js */ \"./node_modules/@babylonjs/core/Cameras/camera.js\");\n/* harmony import */ var _babylonjs_core_Materials_multiMaterial_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @babylonjs/core/Materials/multiMaterial.js */ \"./node_modules/@babylonjs/core/Materials/multiMaterial.js\");\n/* harmony import */ var _babylonjs_core_Materials_PBR_pbrBaseMaterial_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @babylonjs/core/Materials/PBR/pbrBaseMaterial.js */ \"./node_modules/@babylonjs/core/Materials/PBR/pbrBaseMaterial.js\");\n/* harmony import */ var _babylonjs_core_Materials_standardMaterial_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @babylonjs/core/Materials/standardMaterial.js */ \"./node_modules/@babylonjs/core/Materials/standardMaterial.js\");\n/* harmony import */ var _babylonjs_core_Misc_logger_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @babylonjs/core/Misc/logger.js */ \"./node_modules/@babylonjs/core/Misc/logger.js\");\n/* harmony import */ var _babylonjs_core_Buffers_bufferUtils_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @babylonjs/core/Buffers/bufferUtils.js */ \"./node_modules/@babylonjs/core/Buffers/bufferUtils.js\");\n/* harmony import */ var _glTFAnimation_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./glTFAnimation.js */ \"./node_modules/@babylonjs/serializers/glTF/2.0/glTFAnimation.js\");\n/* harmony import */ var _glTFMorphTargetsUtilities_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./glTFMorphTargetsUtilities.js */ \"./node_modules/@babylonjs/serializers/glTF/2.0/glTFMorphTargetsUtilities.js\");\n/* harmony import */ var _babylonjs_core_Meshes_linesMesh_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @babylonjs/core/Meshes/linesMesh.js */ \"./node_modules/@babylonjs/core/Meshes/linesMesh.js\");\n/* harmony import */ var _babylonjs_core_Meshes_GreasedLine_greasedLineBaseMesh_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @babylonjs/core/Meshes/GreasedLine/greasedLineBaseMesh.js */ \"./node_modules/@babylonjs/core/Meshes/GreasedLine/greasedLineBaseMesh.js\");\n/* harmony import */ var _babylonjs_core_Maths_math_color_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @babylonjs/core/Maths/math.color.js */ \"./node_modules/@babylonjs/core/Maths/math.color.js\");\n/* harmony import */ var _babylonjs_core_Cameras_targetCamera_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @babylonjs/core/Cameras/targetCamera.js */ \"./node_modules/@babylonjs/core/Cameras/targetCamera.js\");\n/* harmony import */ var _babylonjs_core_Maths_math_constants_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! @babylonjs/core/Maths/math.constants.js */ \"./node_modules/@babylonjs/core/Maths/math.constants.js\");\n/* harmony import */ var _dataWriter_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./dataWriter.js */ \"./node_modules/@babylonjs/serializers/glTF/2.0/dataWriter.js\");\n/* harmony import */ var _babylonjs_core_Materials_PBR_openpbrMaterial_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! @babylonjs/core/Materials/PBR/openpbrMaterial.js */ \"./node_modules/@babylonjs/core/Materials/PBR/openpbrMaterial.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass ExporterState {\n    constructor(convertToRightHanded, wasAddedByNoopNode) {\n        // Babylon indices array, start, count, offset, flip -> glTF accessor index\n        this._indicesAccessorMap = new Map();\n        // Babylon buffer -> glTF buffer view\n        this._vertexBufferViewMap = new Map();\n        // Babylon vertex buffer, start, count -> glTF accessor index\n        this._vertexAccessorMap = new Map();\n        this._remappedBufferView = new Map();\n        this._meshMorphTargetMap = new Map();\n        this._vertexMapColorAlpha = new Map();\n        this._exportedNodes = new Set();\n        // Babylon mesh -> glTF mesh index\n        this._meshMap = new Map();\n        // Only used when convertToRightHanded is true.\n        this.convertedToRightHandedBuffers = new Map();\n        this.convertToRightHanded = convertToRightHanded;\n        this.wasAddedByNoopNode = wasAddedByNoopNode;\n    }\n    getIndicesAccessor(indices, start, count, offset, flip) {\n        return this._indicesAccessorMap.get(indices)?.get(start)?.get(count)?.get(offset)?.get(flip);\n    }\n    setIndicesAccessor(indices, start, count, offset, flip, accessorIndex) {\n        let map1 = this._indicesAccessorMap.get(indices);\n        if (!map1) {\n            map1 = new Map();\n            this._indicesAccessorMap.set(indices, map1);\n        }\n        let map2 = map1.get(start);\n        if (!map2) {\n            map2 = new Map();\n            map1.set(start, map2);\n        }\n        let map3 = map2.get(count);\n        if (!map3) {\n            map3 = new Map();\n            map2.set(count, map3);\n        }\n        let map4 = map3.get(offset);\n        if (!map4) {\n            map4 = new Map();\n            map3.set(offset, map4);\n        }\n        map4.set(flip, accessorIndex);\n    }\n    pushExportedNode(node) {\n        if (!this._exportedNodes.has(node)) {\n            this._exportedNodes.add(node);\n        }\n    }\n    getNodesSet() {\n        return this._exportedNodes;\n    }\n    getVertexBufferView(buffer) {\n        return this._vertexBufferViewMap.get(buffer);\n    }\n    setVertexBufferView(buffer, bufferView) {\n        this._vertexBufferViewMap.set(buffer, bufferView);\n    }\n    setRemappedBufferView(buffer, vertexBuffer, bufferView) {\n        this._remappedBufferView.set(buffer, new Map());\n        this._remappedBufferView.get(buffer).set(vertexBuffer, bufferView);\n    }\n    getRemappedBufferView(buffer, vertexBuffer) {\n        return this._remappedBufferView.get(buffer)?.get(vertexBuffer);\n    }\n    getVertexAccessor(vertexBuffer, start, count) {\n        return this._vertexAccessorMap.get(vertexBuffer)?.get(start)?.get(count);\n    }\n    setVertexAccessor(vertexBuffer, start, count, accessorIndex) {\n        let map1 = this._vertexAccessorMap.get(vertexBuffer);\n        if (!map1) {\n            map1 = new Map();\n            this._vertexAccessorMap.set(vertexBuffer, map1);\n        }\n        let map2 = map1.get(start);\n        if (!map2) {\n            map2 = new Map();\n            map1.set(start, map2);\n        }\n        map2.set(count, accessorIndex);\n    }\n    hasVertexColorAlpha(vertexBuffer) {\n        return this._vertexMapColorAlpha.get(vertexBuffer) || false;\n    }\n    setHasVertexColorAlpha(vertexBuffer, hasAlpha) {\n        return this._vertexMapColorAlpha.set(vertexBuffer, hasAlpha);\n    }\n    getMesh(mesh) {\n        return this._meshMap.get(mesh);\n    }\n    setMesh(mesh, meshIndex) {\n        this._meshMap.set(mesh, meshIndex);\n    }\n    bindMorphDataToMesh(mesh, morphData) {\n        const morphTargets = this._meshMorphTargetMap.get(mesh) || [];\n        this._meshMorphTargetMap.set(mesh, morphTargets);\n        if (morphTargets.indexOf(morphData) === -1) {\n            morphTargets.push(morphData);\n        }\n    }\n    getMorphTargetsFromMesh(mesh) {\n        return this._meshMorphTargetMap.get(mesh);\n    }\n}\n/** @internal */\nclass GLTFExporter {\n    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/promise-function-async\n    _ApplyExtension(node, extensions, index, actionAsync) {\n        if (index >= extensions.length) {\n            return Promise.resolve(node);\n        }\n        const currentPromise = actionAsync(extensions[index], node);\n        if (!currentPromise) {\n            return this._ApplyExtension(node, extensions, index + 1, actionAsync);\n        }\n        // eslint-disable-next-line github/no-then\n        return currentPromise.then(async (newNode) => (newNode ? await this._ApplyExtension(newNode, extensions, index + 1, actionAsync) : null));\n    }\n    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/promise-function-async\n    _ApplyExtensions(node, actionAsync) {\n        const extensions = [];\n        for (const name of GLTFExporter._ExtensionNames) {\n            extensions.push(this._extensions[name]);\n        }\n        return this._ApplyExtension(node, extensions, 0, actionAsync);\n    }\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async\n    _extensionsPostExportNodeAsync(context, node, babylonNode, nodeMap, convertToRightHanded) {\n        return this._ApplyExtensions(node, \n        // eslint-disable-next-line @typescript-eslint/promise-function-async\n        (extension, node) => extension.postExportNodeAsync && extension.postExportNodeAsync(context, node, babylonNode, nodeMap, convertToRightHanded, this._bufferManager));\n    }\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async\n    _extensionsPostExportMaterialAsync(context, material, babylonMaterial) {\n        // eslint-disable-next-line @typescript-eslint/promise-function-async\n        return this._ApplyExtensions(material, (extension, node) => extension.postExportMaterialAsync && extension.postExportMaterialAsync(context, node, babylonMaterial));\n    }\n    /**\n     * Get additional textures for a material\n     * @param context The context when loading the asset\n     * @param material The glTF material\n     * @param babylonMaterial The Babylon.js material\n     * @returns List of additional textures\n     */\n    async _extensionsPostExportMaterialAdditionalTexturesAsync(context, material, babylonMaterial) {\n        const output = [];\n        await Promise.all(GLTFExporter._ExtensionNames.map(async (name) => {\n            const extension = this._extensions[name];\n            if (extension.postExportMaterialAdditionalTexturesAsync) {\n                const textures = await extension.postExportMaterialAdditionalTexturesAsync(context, material, babylonMaterial);\n                output.push(...textures);\n            }\n        }));\n        return output;\n    }\n    _extensionsPostExportTextures(context, textureInfo, babylonTexture) {\n        for (const name of GLTFExporter._ExtensionNames) {\n            const extension = this._extensions[name];\n            if (extension.postExportTexture) {\n                extension.postExportTexture(context, textureInfo, babylonTexture);\n            }\n        }\n    }\n    _extensionsPostExportMeshPrimitive(primitive) {\n        for (const name of GLTFExporter._ExtensionNames) {\n            const extension = this._extensions[name];\n            if (extension.postExportMeshPrimitive) {\n                extension.postExportMeshPrimitive(primitive, this._bufferManager, this._accessors);\n            }\n        }\n    }\n    async _extensionsPreGenerateBinaryAsync() {\n        for (const name of GLTFExporter._ExtensionNames) {\n            const extension = this._extensions[name];\n            if (extension.preGenerateBinaryAsync) {\n                // eslint-disable-next-line no-await-in-loop\n                await extension.preGenerateBinaryAsync(this._bufferManager);\n            }\n        }\n    }\n    _forEachExtensions(action) {\n        for (const name of GLTFExporter._ExtensionNames) {\n            const extension = this._extensions[name];\n            if (extension.enabled) {\n                action(extension);\n            }\n        }\n    }\n    _extensionsOnExporting() {\n        this._forEachExtensions((extension) => {\n            var _a, _b, _c;\n            if (extension.wasUsed) {\n                (_a = this._glTF).extensionsUsed || (_a.extensionsUsed = []);\n                if (this._glTF.extensionsUsed.indexOf(extension.name) === -1) {\n                    this._glTF.extensionsUsed.push(extension.name);\n                }\n                if (extension.required) {\n                    (_b = this._glTF).extensionsRequired || (_b.extensionsRequired = []);\n                    if (this._glTF.extensionsRequired.indexOf(extension.name) === -1) {\n                        this._glTF.extensionsRequired.push(extension.name);\n                    }\n                }\n                (_c = this._glTF).extensions || (_c.extensions = {});\n                if (extension.onExporting) {\n                    extension.onExporting();\n                }\n            }\n        });\n    }\n    _loadExtensions() {\n        for (const name of GLTFExporter._ExtensionNames) {\n            const extension = GLTFExporter._ExtensionFactories[name](this);\n            this._extensions[name] = extension;\n        }\n    }\n    constructor(babylonScene = _babylonjs_core_Engines_engineStore_js__WEBPACK_IMPORTED_MODULE_8__.EngineStore.LastCreatedScene, options) {\n        this._glTF = {\n            asset: { generator: `Babylon.js v${_babylonjs_core_Engines_engine_js__WEBPACK_IMPORTED_MODULE_7__.Engine.Version}`, version: \"2.0\" },\n        };\n        this._animations = [];\n        this._accessors = [];\n        this._bufferViews = [];\n        this._cameras = [];\n        this._images = [];\n        this._materials = [];\n        this._meshes = [];\n        this._nodes = [];\n        this._samplers = [];\n        this._scenes = [];\n        this._skins = [];\n        this._textures = [];\n        this._imageData = {};\n        this._shouldUseGlb = false;\n        this._materialExporter = new _glTFMaterialExporter_js__WEBPACK_IMPORTED_MODULE_9__.GLTFMaterialExporter(this);\n        this._extensions = {};\n        this._bufferManager = new _bufferManager_js__WEBPACK_IMPORTED_MODULE_13__.BufferManager();\n        this._shouldExportNodeMap = new Map();\n        // Babylon node -> glTF node index\n        this._nodeMap = new Map();\n        // Babylon material -> glTF material index\n        this._materialMap = new Map();\n        this._camerasMap = new Map();\n        this._nodesCameraMap = new Map();\n        this._skinMap = new Map();\n        this._nodesSkinMap = new Map();\n        // A material in this set requires UVs\n        this._materialNeedsUVsSet = new Set();\n        if (!babylonScene) {\n            throw new Error(\"No scene available to export\");\n        }\n        this._babylonScene = babylonScene;\n        this._options = {\n            shouldExportNode: () => true,\n            shouldExportAnimation: () => true,\n            metadataSelector: (metadata) => metadata?.gltf?.extras,\n            animationSampleRate: 1 / 60,\n            exportWithoutWaitingForScene: false,\n            exportUnusedUVs: false,\n            removeNoopRootNodes: true,\n            includeCoordinateSystemConversionNodes: false,\n            meshCompressionMethod: \"None\",\n            ...options,\n        };\n        this._loadExtensions();\n    }\n    dispose() {\n        for (const key in this._extensions) {\n            const extension = this._extensions[key];\n            extension.dispose();\n        }\n    }\n    get options() {\n        return this._options;\n    }\n    static RegisterExtension(name, factory, order = 100) {\n        if (GLTFExporter.UnregisterExtension(name)) {\n            _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.Warn(`Extension with the name ${name} already exists`);\n        }\n        GLTFExporter._ExtensionFactories[name] = factory;\n        const extensionOrder = order ?? 0; // Use provided order or default to 0\n        GLTFExporter._ExtensionOrders[name] = extensionOrder;\n        // Find the correct position to insert the extension based on order\n        let insertIndex = GLTFExporter._ExtensionNames.length;\n        for (let i = 0; i < GLTFExporter._ExtensionNames.length; i++) {\n            const existingName = GLTFExporter._ExtensionNames[i];\n            const existingOrder = GLTFExporter._ExtensionOrders[existingName];\n            // If the order is less, insert before.\n            if (extensionOrder < existingOrder) {\n                insertIndex = i;\n                break;\n            }\n        }\n        GLTFExporter._ExtensionNames.splice(insertIndex, 0, name);\n    }\n    static UnregisterExtension(name) {\n        if (!GLTFExporter._ExtensionFactories[name]) {\n            return false;\n        }\n        delete GLTFExporter._ExtensionFactories[name];\n        delete GLTFExporter._ExtensionOrders[name];\n        const index = GLTFExporter._ExtensionNames.indexOf(name);\n        if (index !== -1) {\n            GLTFExporter._ExtensionNames.splice(index, 1);\n        }\n        return true;\n    }\n    _generateJSON(bufferByteLength, fileName, prettyPrint) {\n        const buffer = { byteLength: bufferByteLength };\n        if (buffer.byteLength) {\n            this._glTF.buffers = [buffer];\n        }\n        if (this._nodes && this._nodes.length) {\n            this._glTF.nodes = this._nodes;\n        }\n        if (this._meshes && this._meshes.length) {\n            this._glTF.meshes = this._meshes;\n        }\n        if (this._scenes && this._scenes.length) {\n            this._glTF.scenes = this._scenes;\n            this._glTF.scene = 0;\n        }\n        if (this._cameras && this._cameras.length) {\n            this._glTF.cameras = this._cameras;\n        }\n        if (this._bufferViews && this._bufferViews.length) {\n            this._glTF.bufferViews = this._bufferViews;\n        }\n        if (this._accessors && this._accessors.length) {\n            this._glTF.accessors = this._accessors;\n        }\n        if (this._animations && this._animations.length) {\n            this._glTF.animations = this._animations;\n        }\n        if (this._materials && this._materials.length) {\n            this._glTF.materials = this._materials;\n        }\n        if (this._textures && this._textures.length) {\n            this._glTF.textures = this._textures;\n        }\n        if (this._samplers && this._samplers.length) {\n            this._glTF.samplers = this._samplers;\n        }\n        if (this._skins && this._skins.length) {\n            this._glTF.skins = this._skins;\n        }\n        if (this._images && this._images.length) {\n            this._glTF.images = this._images;\n        }\n        if (!this._shouldUseGlb) {\n            buffer.uri = fileName + \".bin\";\n        }\n        return prettyPrint ? JSON.stringify(this._glTF, null, 2) : JSON.stringify(this._glTF);\n    }\n    async generateGLTFAsync(glTFPrefix) {\n        const binaryBuffer = await this._generateBinaryAsync();\n        this._extensionsOnExporting();\n        const jsonText = this._generateJSON(binaryBuffer.byteLength, glTFPrefix, true);\n        const bin = new Blob([binaryBuffer], { type: \"application/octet-stream\" });\n        const glTFFileName = glTFPrefix + \".gltf\";\n        const glTFBinFile = glTFPrefix + \".bin\";\n        const container = new _glTFData_js__WEBPACK_IMPORTED_MODULE_10__.GLTFData();\n        container.files[glTFFileName] = jsonText;\n        container.files[glTFBinFile] = bin;\n        if (this._imageData) {\n            for (const image in this._imageData) {\n                container.files[image] = this._imageData[image];\n            }\n        }\n        return container;\n    }\n    async _generateBinaryAsync() {\n        await this._exportSceneAsync();\n        await this._extensionsPreGenerateBinaryAsync();\n        return this._bufferManager.generateBinary(this._bufferViews);\n    }\n    /**\n     * Pads the number to a multiple of 4\n     * @param num number to pad\n     * @returns padded number\n     */\n    _getPadding(num) {\n        const remainder = num % 4;\n        const padding = remainder === 0 ? remainder : 4 - remainder;\n        return padding;\n    }\n    async generateGLBAsync(glTFPrefix) {\n        this._shouldUseGlb = true;\n        const binaryBuffer = await this._generateBinaryAsync();\n        this._extensionsOnExporting();\n        const jsonText = this._generateJSON(binaryBuffer.byteLength);\n        const glbFileName = glTFPrefix + \".glb\";\n        const headerLength = 12;\n        const chunkLengthPrefix = 8;\n        let jsonLength = jsonText.length;\n        let encodedJsonText;\n        // Make use of TextEncoder when available\n        if (typeof TextEncoder !== \"undefined\") {\n            const encoder = new TextEncoder();\n            encodedJsonText = encoder.encode(jsonText);\n            jsonLength = encodedJsonText.length;\n        }\n        const jsonPadding = this._getPadding(jsonLength);\n        const binPadding = this._getPadding(binaryBuffer.byteLength);\n        const byteLength = headerLength + 2 * chunkLengthPrefix + jsonLength + jsonPadding + binaryBuffer.byteLength + binPadding;\n        const dataWriter = new _dataWriter_js__WEBPACK_IMPORTED_MODULE_27__.DataWriter(byteLength);\n        // Header\n        dataWriter.writeUInt32(0x46546c67); // \"glTF\"\n        dataWriter.writeUInt32(2); // Version\n        dataWriter.writeUInt32(byteLength); // Total bytes in file\n        // JSON chunk length prefix\n        dataWriter.writeUInt32(jsonLength + jsonPadding);\n        dataWriter.writeUInt32(0x4e4f534a); // \"JSON\"\n        // JSON chunk bytes\n        if (encodedJsonText) {\n            // If TextEncoder was available, we can simply copy the encoded array\n            dataWriter.writeTypedArray(encodedJsonText);\n        }\n        else {\n            const blankCharCode = \"_\".charCodeAt(0);\n            for (let i = 0; i < jsonLength; ++i) {\n                const charCode = jsonText.charCodeAt(i);\n                // If the character doesn't fit into a single UTF-16 code unit, just put a blank character\n                if (charCode != jsonText.codePointAt(i)) {\n                    dataWriter.writeUInt8(blankCharCode);\n                }\n                else {\n                    dataWriter.writeUInt8(charCode);\n                }\n            }\n        }\n        // JSON padding\n        for (let i = 0; i < jsonPadding; ++i) {\n            dataWriter.writeUInt8(0x20);\n        }\n        // Binary chunk length prefix\n        dataWriter.writeUInt32(binaryBuffer.byteLength + binPadding);\n        dataWriter.writeUInt32(0x004e4942); // \"BIN\"\n        // Binary chunk bytes\n        dataWriter.writeTypedArray(binaryBuffer);\n        // Binary padding\n        for (let i = 0; i < binPadding; ++i) {\n            dataWriter.writeUInt8(0);\n        }\n        const container = new _glTFData_js__WEBPACK_IMPORTED_MODULE_10__.GLTFData();\n        container.files[glbFileName] = new Blob([dataWriter.getOutputData()], { type: \"application/octet-stream\" });\n        return container;\n    }\n    _setNodeTransformation(node, babylonTransformNode, convertToRightHanded) {\n        if (!babylonTransformNode.getPivotPoint().equalsWithEpsilon(_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__.DefaultTranslation, _babylonjs_core_Maths_math_constants_js__WEBPACK_IMPORTED_MODULE_26__.Epsilon)) {\n            _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.Warn(\"Pivot points are not supported in the glTF serializer\");\n        }\n        if (!babylonTransformNode.position.equalsWithEpsilon(_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__.DefaultTranslation, _babylonjs_core_Maths_math_constants_js__WEBPACK_IMPORTED_MODULE_26__.Epsilon)) {\n            const translation = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[0].copyFrom(babylonTransformNode.position);\n            if (convertToRightHanded) {\n                (0,_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__.ConvertToRightHandedPosition)(translation);\n            }\n            node.translation = translation.asArray();\n        }\n        if (!babylonTransformNode.scaling.equalsWithEpsilon(_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__.DefaultScale, _babylonjs_core_Maths_math_constants_js__WEBPACK_IMPORTED_MODULE_26__.Epsilon)) {\n            node.scale = babylonTransformNode.scaling.asArray();\n        }\n        const rotationQuaternion = babylonTransformNode.rotationQuaternion?.clone() ||\n            _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Quaternion.FromEulerAngles(babylonTransformNode.rotation.x, babylonTransformNode.rotation.y, babylonTransformNode.rotation.z);\n        if (!rotationQuaternion.equalsWithEpsilon(_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__.DefaultRotation, _babylonjs_core_Maths_math_constants_js__WEBPACK_IMPORTED_MODULE_26__.Epsilon)) {\n            if (convertToRightHanded) {\n                (0,_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__.ConvertToRightHandedRotation)(rotationQuaternion);\n            }\n            node.rotation = rotationQuaternion.normalize().asArray();\n        }\n    }\n    _setCameraTransformation(node, babylonCamera, convertToRightHanded) {\n        // Camera types store rotation differently (e.g., ArcRotateCamera uses alpha/beta, others use rotationQuaternion).\n        // Extract the transform from the world matrix instead of handling each case separately.\n        const translation = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[0];\n        const rotationQuaternion = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Quaternion[0];\n        const cameraWorldMatrix = babylonCamera.getWorldMatrix();\n        if (babylonCamera.parent) {\n            // Camera.getWorldMatrix returns global coordinates. GLTF node must use local coordinates. If camera has parent we need to use local translation/rotation.\n            const parentInvWorldMatrix = babylonCamera.parent.getWorldMatrix().invertToRef(_babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Matrix[0]);\n            const cameraLocal = cameraWorldMatrix.multiplyToRef(parentInvWorldMatrix, _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Matrix[1]);\n            cameraLocal.decompose(undefined, rotationQuaternion, translation);\n        }\n        else {\n            cameraWorldMatrix.decompose(undefined, rotationQuaternion, translation);\n        }\n        if (!translation.equalsWithEpsilon(_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__.DefaultTranslation, _babylonjs_core_Maths_math_constants_js__WEBPACK_IMPORTED_MODULE_26__.Epsilon)) {\n            if (convertToRightHanded) {\n                (0,_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__.ConvertToRightHandedPosition)(translation);\n            }\n            node.translation = translation.asArray();\n        }\n        if (convertToRightHanded) {\n            (0,_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__.ConvertToRightHandedRotation)(rotationQuaternion);\n        }\n        // Left-handed scenes have cameras that always face Z+ (opposite of glTF's Z-).\n        // Use scene coordinate system rather than convertToRightHanded, since some\n        // cameras may not need convertToRightHanded but still need correction to face Z-.\n        if (!this._babylonScene.useRightHandedSystem) {\n            (0,_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__.Rotate180Y)(rotationQuaternion);\n        }\n        if (!rotationQuaternion.equalsWithEpsilon(_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__.DefaultRotation, _babylonjs_core_Maths_math_constants_js__WEBPACK_IMPORTED_MODULE_26__.Epsilon)) {\n            node.rotation = rotationQuaternion.asArray();\n        }\n    }\n    // Export babylon cameras to glTF cameras\n    _listAvailableCameras() {\n        for (const camera of this._babylonScene.cameras) {\n            const glTFCamera = {\n                type: camera.mode === _babylonjs_core_Cameras_camera_js__WEBPACK_IMPORTED_MODULE_14__.Camera.PERSPECTIVE_CAMERA ? \"perspective\" /* CameraType.PERSPECTIVE */ : \"orthographic\" /* CameraType.ORTHOGRAPHIC */,\n            };\n            if (camera.name) {\n                glTFCamera.name = camera.name;\n            }\n            if (glTFCamera.type === \"perspective\" /* CameraType.PERSPECTIVE */) {\n                glTFCamera.perspective = {\n                    aspectRatio: camera.getEngine().getAspectRatio(camera),\n                    yfov: camera.fovMode === _babylonjs_core_Cameras_camera_js__WEBPACK_IMPORTED_MODULE_14__.Camera.FOVMODE_VERTICAL_FIXED ? camera.fov : camera.fov * camera.getEngine().getAspectRatio(camera),\n                    znear: camera.minZ,\n                    zfar: camera.maxZ,\n                };\n            }\n            else if (glTFCamera.type === \"orthographic\" /* CameraType.ORTHOGRAPHIC */) {\n                const halfWidth = camera.orthoLeft && camera.orthoRight ? 0.5 * (camera.orthoRight - camera.orthoLeft) : camera.getEngine().getRenderWidth() * 0.5;\n                const halfHeight = camera.orthoBottom && camera.orthoTop ? 0.5 * (camera.orthoTop - camera.orthoBottom) : camera.getEngine().getRenderHeight() * 0.5;\n                glTFCamera.orthographic = {\n                    xmag: halfWidth,\n                    ymag: halfHeight,\n                    znear: camera.minZ,\n                    zfar: camera.maxZ,\n                };\n            }\n            this._camerasMap.set(camera, glTFCamera);\n        }\n    }\n    // Cleanup unused cameras and assign index to nodes.\n    _exportAndAssignCameras() {\n        const gltfCameras = Array.from(this._camerasMap.values());\n        for (const gltfCamera of gltfCameras) {\n            const usedNodes = this._nodesCameraMap.get(gltfCamera);\n            if (usedNodes !== undefined) {\n                this._cameras.push(gltfCamera);\n                for (const node of usedNodes) {\n                    node.camera = this._cameras.length - 1;\n                }\n            }\n        }\n    }\n    // Collects all skins in a skins map so nodes can reference it during node parsing.\n    _listAvailableSkeletons() {\n        for (const skeleton of this._babylonScene.skeletons) {\n            if (skeleton.bones.length <= 0) {\n                continue;\n            }\n            const skin = { joints: [] };\n            this._skinMap.set(skeleton, skin);\n        }\n    }\n    _exportAndAssignSkeletons(leftHandNodes) {\n        for (const skeleton of this._babylonScene.skeletons) {\n            if (skeleton.bones.length <= 0) {\n                continue;\n            }\n            const skin = this._skinMap.get(skeleton);\n            if (skin == undefined) {\n                continue;\n            }\n            // The bones (joints) of a skeleton (skin) must be exported in the same order as they appear in vertex attributes,\n            // which is indicated by getIndex and may not match a bone's index in skeleton.bones\n            const boneIndexMap = {};\n            let maxBoneIndex = -1;\n            for (let i = 0; i < skeleton.bones.length; ++i) {\n                const bone = skeleton.bones[i];\n                const boneIndex = bone.getIndex() ?? i;\n                if (boneIndex !== -1) {\n                    boneIndexMap[boneIndex] = bone;\n                    if (boneIndex > maxBoneIndex) {\n                        maxBoneIndex = boneIndex;\n                    }\n                }\n            }\n            // Set joints indices to scene nodes.\n            const inverseBindMatrices = [];\n            for (let boneIndex = 0; boneIndex <= maxBoneIndex; ++boneIndex) {\n                const bone = boneIndexMap[boneIndex]; // Assumes no gaps in bone indices\n                const transformNode = bone.getTransformNode();\n                const nodeIndex = transformNode ? this._nodeMap.get(transformNode) : undefined;\n                if (nodeIndex === undefined) {\n                    _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.Warn(\"Exporting a bone without a linked transform node is currently unsupported.\");\n                    continue; // The indices may be out-of-sync after this and break the skinning.\n                }\n                skin.joints.push(nodeIndex);\n                const boneMatrix = bone.getAbsoluteInverseBindMatrix().clone();\n                if (leftHandNodes.has(transformNode)) {\n                    (0,_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__.ConvertToRightHandedTransformMatrix)(boneMatrix);\n                }\n                inverseBindMatrices.push(boneMatrix);\n            }\n            // Nodes that use this skin.\n            const skinnedNodes = this._nodesSkinMap.get(skin);\n            // Only export the skin if it has at least one joint and is used by a mesh.\n            if (skin.joints.length > 0 && skinnedNodes !== undefined) {\n                const inverseBindMatricesData = new Float32Array(inverseBindMatrices.length * 16); // Always a 4 x 4 matrix of 32 bit float\n                inverseBindMatrices.forEach((mat, index) => {\n                    inverseBindMatricesData.set(mat.m, index * 16);\n                });\n                const bufferView = this._bufferManager.createBufferView(inverseBindMatricesData);\n                this._accessors.push(this._bufferManager.createAccessor(bufferView, \"MAT4\" /* AccessorType.MAT4 */, 5126 /* AccessorComponentType.FLOAT */, inverseBindMatrices.length));\n                skin.inverseBindMatrices = this._accessors.length - 1;\n                this._skins.push(skin);\n                const skinIndex = this._skins.length - 1;\n                for (const skinnedNode of skinnedNodes) {\n                    skinnedNode.skin = skinIndex;\n                }\n            }\n        }\n    }\n    async _exportSceneAsync() {\n        const scene = { nodes: [] };\n        // Scene metadata\n        if (this._babylonScene.metadata) {\n            const extras = this._options.metadataSelector(this._babylonScene.metadata);\n            if (extras) {\n                scene.extras = extras;\n            }\n        }\n        //  TODO:\n        //  deal with this from the loader:\n        //  babylonMaterial.invertNormalMapX = !this._babylonScene.useRightHandedSystem;\n        //  babylonMaterial.invertNormalMapY = this._babylonScene.useRightHandedSystem;\n        const rootNodesRH = new Array();\n        const rootNodesLH = new Array();\n        const rootNoopNodesRH = new Array();\n        for (const rootNode of this._babylonScene.rootNodes) {\n            if (this._options.removeNoopRootNodes && !this._options.includeCoordinateSystemConversionNodes && (0,_exportUtils_js__WEBPACK_IMPORTED_MODULE_12__.IsNoopNode)(rootNode, this._babylonScene.useRightHandedSystem)) {\n                rootNoopNodesRH.push(...rootNode.getChildren());\n            }\n            else if (this._babylonScene.useRightHandedSystem) {\n                rootNodesRH.push(rootNode);\n            }\n            else {\n                rootNodesLH.push(rootNode);\n            }\n        }\n        this._listAvailableCameras();\n        this._listAvailableSkeletons();\n        const stateLH = new ExporterState(true, false);\n        scene.nodes.push(...(await this._exportNodesAsync(rootNodesLH, stateLH)));\n        const stateRH = new ExporterState(false, false);\n        scene.nodes.push(...(await this._exportNodesAsync(rootNodesRH, stateRH)));\n        const noopRH = new ExporterState(false, true);\n        scene.nodes.push(...(await this._exportNodesAsync(rootNoopNodesRH, noopRH)));\n        if (scene.nodes.length) {\n            this._scenes.push(scene);\n        }\n        this._exportAndAssignCameras();\n        this._exportAndAssignSkeletons(stateLH.getNodesSet());\n        if (this._babylonScene.animationGroups.length) {\n            _glTFAnimation_js__WEBPACK_IMPORTED_MODULE_20__._GLTFAnimation._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene, this._animations, this._nodeMap, this._bufferManager, this._bufferViews, this._accessors, this._animationSampleRate, stateLH.getNodesSet(), this._options.shouldExportAnimation);\n        }\n    }\n    _shouldExportNode(babylonNode) {\n        let result = this._shouldExportNodeMap.get(babylonNode);\n        if (result === undefined) {\n            result = this._options.shouldExportNode(babylonNode);\n            this._shouldExportNodeMap.set(babylonNode, result);\n        }\n        return result;\n    }\n    async _exportNodesAsync(babylonRootNodes, state) {\n        const nodes = new Array();\n        this._exportBuffers(babylonRootNodes, state);\n        for (const babylonNode of babylonRootNodes) {\n            // eslint-disable-next-line no-await-in-loop\n            await this._exportNodeAsync(babylonNode, nodes, state);\n        }\n        return nodes;\n    }\n    _collectBuffers(babylonNode, bufferToVertexBuffersMap, vertexBufferToMeshesMap, morphTargetsToMeshesMap, state) {\n        if (this._shouldExportNode(babylonNode) && babylonNode instanceof _babylonjs_core_Meshes_abstractMesh_js__WEBPACK_IMPORTED_MODULE_4__.AbstractMesh && babylonNode.geometry) {\n            const vertexBuffers = babylonNode.geometry.getVertexBuffers();\n            if (vertexBuffers) {\n                for (const kind in vertexBuffers) {\n                    if (!(0,_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__.IsStandardVertexAttribute)(kind)) {\n                        continue;\n                    }\n                    const vertexBuffer = vertexBuffers[kind];\n                    state.setHasVertexColorAlpha(vertexBuffer, babylonNode.hasVertexAlpha);\n                    const buffer = vertexBuffer._buffer;\n                    const vertexBufferArray = bufferToVertexBuffersMap.get(buffer) || [];\n                    bufferToVertexBuffersMap.set(buffer, vertexBufferArray);\n                    if (vertexBufferArray.indexOf(vertexBuffer) === -1) {\n                        vertexBufferArray.push(vertexBuffer);\n                    }\n                    const meshes = vertexBufferToMeshesMap.get(vertexBuffer) || [];\n                    vertexBufferToMeshesMap.set(vertexBuffer, meshes);\n                    if (meshes.indexOf(babylonNode) === -1) {\n                        meshes.push(babylonNode);\n                    }\n                }\n            }\n            const morphTargetManager = babylonNode.morphTargetManager;\n            if (morphTargetManager) {\n                for (let morphIndex = 0; morphIndex < morphTargetManager.numTargets; morphIndex++) {\n                    const morphTarget = morphTargetManager.getTarget(morphIndex);\n                    const meshes = morphTargetsToMeshesMap.get(morphTarget) || [];\n                    morphTargetsToMeshesMap.set(morphTarget, meshes);\n                    if (meshes.indexOf(babylonNode) === -1) {\n                        meshes.push(babylonNode);\n                    }\n                }\n            }\n        }\n        for (const babylonChildNode of babylonNode.getChildren()) {\n            this._collectBuffers(babylonChildNode, bufferToVertexBuffersMap, vertexBufferToMeshesMap, morphTargetsToMeshesMap, state);\n        }\n    }\n    _exportBuffers(babylonRootNodes, state) {\n        const bufferToVertexBuffersMap = new Map();\n        const vertexBufferToMeshesMap = new Map();\n        const morphTargetsMeshesMap = new Map();\n        for (const babylonNode of babylonRootNodes) {\n            this._collectBuffers(babylonNode, bufferToVertexBuffersMap, vertexBufferToMeshesMap, morphTargetsMeshesMap, state);\n        }\n        const buffers = Array.from(bufferToVertexBuffersMap.keys());\n        for (const buffer of buffers) {\n            const data = buffer.getData();\n            if (!data) {\n                throw new Error(\"Buffer data is not available\");\n            }\n            const vertexBuffers = bufferToVertexBuffersMap.get(buffer);\n            if (!vertexBuffers) {\n                continue;\n            }\n            const byteStride = vertexBuffers[0].byteStride;\n            if (vertexBuffers.some((vertexBuffer) => vertexBuffer.byteStride !== byteStride)) {\n                throw new Error(\"Vertex buffers pointing to the same buffer must have the same byte stride\");\n            }\n            const bytes = (0,_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__.DataArrayToUint8Array)(data).slice();\n            // Apply normalizations and color corrections to buffer data in-place.\n            for (const vertexBuffer of vertexBuffers) {\n                const meshes = vertexBufferToMeshesMap.get(vertexBuffer);\n                const { byteOffset, byteStride, componentCount, type, count, normalized, kind } = (0,_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__.GetVertexBufferInfo)(vertexBuffer, meshes);\n                switch (kind) {\n                    // Normalize normals and tangents.\n                    case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_2__.VertexBuffer.NormalKind:\n                    case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_2__.VertexBuffer.TangentKind: {\n                        (0,_babylonjs_core_Buffers_bufferUtils_js__WEBPACK_IMPORTED_MODULE_19__.EnumerateFloatValues)(bytes, byteOffset, byteStride, componentCount, type, count, normalized, (values) => {\n                            const length = Math.sqrt(values[0] * values[0] + values[1] * values[1] + values[2] * values[2]);\n                            if (length > 0) {\n                                const invLength = 1 / length;\n                                values[0] *= invLength;\n                                values[1] *= invLength;\n                                values[2] *= invLength;\n                            }\n                        });\n                        break;\n                    }\n                    // Convert StandardMaterial vertex colors from gamma to linear space.\n                    case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_2__.VertexBuffer.ColorKind: {\n                        const stdMaterialCount = meshes.filter((mesh) => mesh.material instanceof _babylonjs_core_Materials_standardMaterial_js__WEBPACK_IMPORTED_MODULE_17__.StandardMaterial || mesh.material == null).length;\n                        if (stdMaterialCount == 0) {\n                            break; // Buffer not used by StandardMaterials, so no conversion needed.\n                        }\n                        // TODO: Implement this case.\n                        if (stdMaterialCount != meshes.length) {\n                            _babylonjs_core_Misc_logger_js__WEBPACK_IMPORTED_MODULE_18__.Logger.Warn(\"Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.\");\n                            break;\n                        }\n                        if (type == _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_2__.VertexBuffer.UNSIGNED_BYTE) {\n                            _babylonjs_core_Misc_logger_js__WEBPACK_IMPORTED_MODULE_18__.Logger.Warn(\"Converting uint8 vertex colors to linear space. Results may look incorrect.\");\n                        }\n                        const vertexData3 = new _babylonjs_core_Maths_math_color_js__WEBPACK_IMPORTED_MODULE_24__.Color3();\n                        const vertexData4 = new _babylonjs_core_Maths_math_color_js__WEBPACK_IMPORTED_MODULE_24__.Color4();\n                        const useExactSrgbConversions = this._babylonScene.getEngine().useExactSrgbConversions;\n                        (0,_babylonjs_core_Buffers_bufferUtils_js__WEBPACK_IMPORTED_MODULE_19__.EnumerateFloatValues)(bytes, byteOffset, byteStride, componentCount, type, count, normalized, (values) => {\n                            // Using separate Color3 and Color4 objects to ensure the right functions are called.\n                            if (values.length === 3) {\n                                vertexData3.fromArray(values, 0);\n                                vertexData3.toLinearSpaceToRef(vertexData3, useExactSrgbConversions);\n                                vertexData3.toArray(values, 0);\n                            }\n                            else {\n                                vertexData4.fromArray(values, 0);\n                                vertexData4.toLinearSpaceToRef(vertexData4, useExactSrgbConversions);\n                                vertexData4.toArray(values, 0);\n                            }\n                        });\n                    }\n                }\n            }\n            // Perform coordinate conversions, if needed, to buffer data in-place (only for positions, normals and tangents).\n            if (state.convertToRightHanded) {\n                for (const vertexBuffer of vertexBuffers) {\n                    const meshes = vertexBufferToMeshesMap.get(vertexBuffer);\n                    const { byteOffset, byteStride, componentCount, type, count, normalized, kind } = (0,_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__.GetVertexBufferInfo)(vertexBuffer, meshes);\n                    switch (kind) {\n                        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_2__.VertexBuffer.PositionKind:\n                        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_2__.VertexBuffer.NormalKind:\n                        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_2__.VertexBuffer.TangentKind: {\n                            (0,_babylonjs_core_Buffers_bufferUtils_js__WEBPACK_IMPORTED_MODULE_19__.EnumerateFloatValues)(bytes, byteOffset, byteStride, componentCount, type, count, normalized, (values) => {\n                                values[0] = -values[0];\n                            });\n                        }\n                    }\n                }\n                // Save converted bytes for min/max computation.\n                state.convertedToRightHandedBuffers.set(buffer, bytes);\n            }\n            // Create buffer view, but defer accessor creation for later. Instead, track it via ExporterState.\n            const bufferView = this._bufferManager.createBufferView(bytes, byteStride);\n            state.setVertexBufferView(buffer, bufferView);\n            const floatMatricesIndices = new Map();\n            // If buffers are of type MatricesIndicesKind and have float values, we need to create a new buffer instead.\n            for (const vertexBuffer of vertexBuffers) {\n                const meshes = vertexBufferToMeshesMap.get(vertexBuffer);\n                const { kind, totalVertices } = (0,_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__.GetVertexBufferInfo)(vertexBuffer, meshes);\n                switch (kind) {\n                    case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_2__.VertexBuffer.MatricesIndicesKind:\n                    case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_2__.VertexBuffer.MatricesIndicesExtraKind: {\n                        if (vertexBuffer.type == _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_2__.VertexBuffer.FLOAT) {\n                            const floatData = vertexBuffer.getFloatData(totalVertices);\n                            if (floatData !== null) {\n                                floatMatricesIndices.set(vertexBuffer, floatData);\n                            }\n                        }\n                    }\n                }\n            }\n            if (floatMatricesIndices.size !== 0) {\n                _babylonjs_core_Misc_logger_js__WEBPACK_IMPORTED_MODULE_18__.Logger.Warn(`Joint indices conversion needed: some joint indices are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.`);\n            }\n            const floatArrayVertexBuffers = Array.from(floatMatricesIndices.keys());\n            for (const vertexBuffer of floatArrayVertexBuffers) {\n                const array = floatMatricesIndices.get(vertexBuffer);\n                if (!array) {\n                    continue;\n                }\n                const is16Bit = (0,_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__.FloatsNeed16BitInteger)(array);\n                const newArray = new (is16Bit ? Uint16Array : Uint8Array)(array.length);\n                for (let index = 0; index < array.length; index++) {\n                    newArray[index] = array[index];\n                }\n                const bufferView = this._bufferManager.createBufferView(newArray, 4 * (is16Bit ? 2 : 1));\n                state.setRemappedBufferView(buffer, vertexBuffer, bufferView);\n            }\n        }\n        // Build morph targets buffers\n        const morphTargets = Array.from(morphTargetsMeshesMap.keys());\n        for (const morphTarget of morphTargets) {\n            const meshes = morphTargetsMeshesMap.get(morphTarget);\n            if (!meshes) {\n                continue;\n            }\n            const glTFMorphTarget = (0,_glTFMorphTargetsUtilities_js__WEBPACK_IMPORTED_MODULE_21__.BuildMorphTargetBuffers)(morphTarget, meshes[0], this._bufferManager, this._bufferViews, this._accessors, state.convertToRightHanded);\n            for (const mesh of meshes) {\n                state.bindMorphDataToMesh(mesh, glTFMorphTarget);\n            }\n        }\n    }\n    /**\n     * Processes a node to be exported to the glTF file\n     * @returns A promise that resolves once the node has been exported\n     * @internal\n     */\n    async _exportNodeAsync(babylonNode, parentNodeChildren, state) {\n        let nodeIndex = this._nodeMap.get(babylonNode);\n        if (nodeIndex !== undefined) {\n            if (!parentNodeChildren.includes(nodeIndex)) {\n                parentNodeChildren.push(nodeIndex);\n            }\n            return;\n        }\n        const node = await this._createNodeAsync(babylonNode, state);\n        if (node) {\n            nodeIndex = this._nodes.length;\n            this._nodes.push(node);\n            this._nodeMap.set(babylonNode, nodeIndex);\n            state.pushExportedNode(babylonNode);\n            parentNodeChildren.push(nodeIndex);\n            // Process node's animations once the node has been added to nodeMap (TODO: This should be refactored)\n            const runtimeGLTFAnimation = {\n                name: \"runtime animations\",\n                channels: [],\n                samplers: [],\n            };\n            const idleGLTFAnimations = [];\n            if (!this._babylonScene.animationGroups.length) {\n                _glTFAnimation_js__WEBPACK_IMPORTED_MODULE_20__._GLTFAnimation._CreateMorphTargetAnimationFromMorphTargetAnimations(babylonNode, runtimeGLTFAnimation, idleGLTFAnimations, this._nodeMap, this._nodes, this._bufferManager, this._bufferViews, this._accessors, this._animationSampleRate, state.convertToRightHanded, this._options.shouldExportAnimation);\n                if (babylonNode.animations.length) {\n                    _glTFAnimation_js__WEBPACK_IMPORTED_MODULE_20__._GLTFAnimation._CreateNodeAnimationFromNodeAnimations(babylonNode, runtimeGLTFAnimation, idleGLTFAnimations, this._nodeMap, this._nodes, this._bufferManager, this._bufferViews, this._accessors, this._animationSampleRate, state.convertToRightHanded, this._options.shouldExportAnimation);\n                }\n            }\n            if (runtimeGLTFAnimation.channels.length && runtimeGLTFAnimation.samplers.length) {\n                this._animations.push(runtimeGLTFAnimation);\n            }\n            idleGLTFAnimations.forEach((idleGLTFAnimation) => {\n                if (idleGLTFAnimation.channels.length && idleGLTFAnimation.samplers.length) {\n                    this._animations.push(idleGLTFAnimation);\n                }\n            });\n        }\n        // Begin processing child nodes once parent has been added to the node list\n        const children = node ? [] : parentNodeChildren;\n        for (const babylonChildNode of babylonNode.getChildren()) {\n            // eslint-disable-next-line no-await-in-loop\n            await this._exportNodeAsync(babylonChildNode, children, state);\n        }\n        if (node && children.length) {\n            node.children = children;\n        }\n    }\n    /**\n     * Creates a glTF node from a Babylon.js node. If skipped, returns null.\n     * @internal\n     */\n    async _createNodeAsync(babylonNode, state) {\n        if (!this._shouldExportNode(babylonNode)) {\n            return null;\n        }\n        const node = {};\n        if (babylonNode.name) {\n            node.name = babylonNode.name;\n        }\n        // Node metadata\n        if (babylonNode.metadata) {\n            const extras = this._options.metadataSelector(babylonNode.metadata);\n            if (extras) {\n                node.extras = extras;\n            }\n        }\n        if (babylonNode instanceof _babylonjs_core_Meshes_transformNode_js__WEBPACK_IMPORTED_MODULE_3__.TransformNode) {\n            this._setNodeTransformation(node, babylonNode, state.convertToRightHanded);\n            if (babylonNode instanceof _babylonjs_core_Meshes_abstractMesh_js__WEBPACK_IMPORTED_MODULE_4__.AbstractMesh) {\n                const babylonMesh = babylonNode instanceof _babylonjs_core_Meshes_instancedMesh_js__WEBPACK_IMPORTED_MODULE_5__.InstancedMesh ? babylonNode.sourceMesh : babylonNode;\n                if (babylonMesh.subMeshes && babylonMesh.subMeshes.length > 0) {\n                    node.mesh = await this._exportMeshAsync(babylonMesh, state);\n                }\n                if (babylonNode.skeleton) {\n                    const skin = this._skinMap.get(babylonNode.skeleton);\n                    if (skin !== undefined) {\n                        if (this._nodesSkinMap.get(skin) === undefined) {\n                            this._nodesSkinMap.set(skin, []);\n                        }\n                        this._nodesSkinMap.get(skin)?.push(node);\n                    }\n                }\n            }\n        }\n        if (babylonNode instanceof _babylonjs_core_Cameras_targetCamera_js__WEBPACK_IMPORTED_MODULE_25__.TargetCamera) {\n            const gltfCamera = this._camerasMap.get(babylonNode);\n            if (gltfCamera) {\n                if (this._nodesCameraMap.get(gltfCamera) === undefined) {\n                    this._nodesCameraMap.set(gltfCamera, []);\n                }\n                this._setCameraTransformation(node, babylonNode, state.convertToRightHanded);\n                // If a parent node exists and can be collapsed, merge their transformations and mark the parent as the camera-containing node.\n                const parentBabylonNode = babylonNode.parent;\n                if (parentBabylonNode !== null && (0,_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__.IsChildCollapsible)(babylonNode, parentBabylonNode)) {\n                    const parentNodeIndex = this._nodeMap.get(parentBabylonNode);\n                    if (parentNodeIndex !== undefined) {\n                        const parentNode = this._nodes[parentNodeIndex];\n                        (0,_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__.CollapseChildIntoParent)(node, parentNode);\n                        this._nodesCameraMap.get(gltfCamera)?.push(parentNode);\n                        return null; // Skip exporting the original child node\n                    }\n                }\n                this._nodesCameraMap.get(gltfCamera)?.push(node);\n            }\n        }\n        // Apply extensions to the node. If this resolves to null, it means we should skip exporting this node\n        const processedNode = await this._extensionsPostExportNodeAsync(\"exportNodeAsync\", node, babylonNode, this._nodeMap, state.convertToRightHanded);\n        if (!processedNode) {\n            _babylonjs_core_Misc_logger_js__WEBPACK_IMPORTED_MODULE_18__.Logger.Warn(`Not exporting node ${babylonNode.name}`);\n            return null;\n        }\n        return node;\n    }\n    _exportIndices(indices, is32Bits, start, count, offset, fillMode, sideOrientation, state, primitive) {\n        let indicesToExport = null;\n        primitive.mode = (0,_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__.GetPrimitiveMode)(fillMode);\n        // Flip indices if triangle winding order is not CCW, as glTF is always CCW.\n        const flip = sideOrientation !== _babylonjs_core_Materials_material_js__WEBPACK_IMPORTED_MODULE_6__.Material.CounterClockWiseSideOrientation && (0,_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__.IsTriangleFillMode)(fillMode);\n        if (flip) {\n            if (fillMode === _babylonjs_core_Materials_material_js__WEBPACK_IMPORTED_MODULE_6__.Material.TriangleStripDrawMode || fillMode === _babylonjs_core_Materials_material_js__WEBPACK_IMPORTED_MODULE_6__.Material.TriangleFanDrawMode) {\n                throw new Error(\"Triangle strip/fan fill mode is not implemented\");\n            }\n            const newIndices = is32Bits ? new Uint32Array(count) : new Uint16Array(count);\n            if (indices) {\n                for (let i = 0; i + 2 < count; i += 3) {\n                    newIndices[i] = indices[start + i] + offset;\n                    newIndices[i + 1] = indices[start + i + 2] + offset;\n                    newIndices[i + 2] = indices[start + i + 1] + offset;\n                }\n            }\n            else {\n                for (let i = 0; i + 2 < count; i += 3) {\n                    newIndices[i] = i;\n                    newIndices[i + 1] = i + 2;\n                    newIndices[i + 2] = i + 1;\n                }\n            }\n            indicesToExport = newIndices;\n        }\n        else if (indices && offset !== 0) {\n            const newIndices = is32Bits ? new Uint32Array(count) : new Uint16Array(count);\n            for (let i = 0; i < count; i++) {\n                newIndices[i] = indices[start + i] + offset;\n            }\n            indicesToExport = newIndices;\n        }\n        else if (indices) {\n            indicesToExport = (0,_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__.IndicesArrayToTypedSubarray)(indices, start, count, is32Bits);\n        }\n        if (indicesToExport) {\n            let accessorIndex = state.getIndicesAccessor(indices, start, count, offset, flip);\n            if (accessorIndex === undefined) {\n                const bufferView = this._bufferManager.createBufferView(indicesToExport);\n                const componentType = is32Bits ? 5125 /* AccessorComponentType.UNSIGNED_INT */ : 5123 /* AccessorComponentType.UNSIGNED_SHORT */;\n                this._accessors.push(this._bufferManager.createAccessor(bufferView, \"SCALAR\" /* AccessorType.SCALAR */, componentType, count, 0));\n                accessorIndex = this._accessors.length - 1;\n                state.setIndicesAccessor(indices, start, count, offset, flip, accessorIndex);\n            }\n            primitive.indices = accessorIndex;\n        }\n    }\n    _exportVertexBuffer(vertexBuffer, babylonMaterial, start, count, state, primitive) {\n        const kind = vertexBuffer.getKind();\n        if (!(0,_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__.IsStandardVertexAttribute)(kind)) {\n            return;\n        }\n        if (kind.startsWith(\"uv\") && !this._options.exportUnusedUVs) {\n            if (!babylonMaterial || !this._materialNeedsUVsSet.has(babylonMaterial)) {\n                return;\n            }\n        }\n        let accessorIndex = state.getVertexAccessor(vertexBuffer, start, count);\n        if (accessorIndex === undefined) {\n            // Get min/max from converted or original data.\n            const data = state.convertedToRightHandedBuffers.get(vertexBuffer._buffer) || vertexBuffer._buffer.getData();\n            const minMax = kind === _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_2__.VertexBuffer.PositionKind ? (0,_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__.GetMinMax)(data, vertexBuffer, start, count) : undefined;\n            // For the remapped buffer views we created for float matrices indices, make sure to use their updated information.\n            const isFloatMatricesIndices = (kind === _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_2__.VertexBuffer.MatricesIndicesKind || kind === _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_2__.VertexBuffer.MatricesIndicesExtraKind) && vertexBuffer.type === _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_2__.VertexBuffer.FLOAT;\n            const vertexBufferType = isFloatMatricesIndices ? _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_2__.VertexBuffer.UNSIGNED_BYTE : vertexBuffer.type;\n            const vertexBufferNormalized = isFloatMatricesIndices ? undefined : vertexBuffer.normalized;\n            const bufferView = isFloatMatricesIndices ? state.getRemappedBufferView(vertexBuffer._buffer, vertexBuffer) : state.getVertexBufferView(vertexBuffer._buffer);\n            const byteOffset = vertexBuffer.byteOffset + start * vertexBuffer.byteStride;\n            this._accessors.push(this._bufferManager.createAccessor(bufferView, (0,_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__.GetAccessorType)(kind, state.hasVertexColorAlpha(vertexBuffer)), vertexBufferType, count, byteOffset, minMax, vertexBufferNormalized // TODO: Find other places where this is needed.\n            ));\n            accessorIndex = this._accessors.length - 1;\n            state.setVertexAccessor(vertexBuffer, start, count, accessorIndex);\n        }\n        primitive.attributes[(0,_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_11__.GetAttributeType)(kind)] = accessorIndex;\n    }\n    async _exportMaterialAsync(babylonMaterial, vertexBuffers, subMesh, primitive) {\n        let materialIndex = this._materialMap.get(babylonMaterial);\n        if (materialIndex === undefined) {\n            const hasUVs = vertexBuffers && Object.keys(vertexBuffers).some((kind) => kind.startsWith(\"uv\"));\n            babylonMaterial = babylonMaterial instanceof _babylonjs_core_Materials_multiMaterial_js__WEBPACK_IMPORTED_MODULE_15__.MultiMaterial ? babylonMaterial.subMaterials[subMesh.materialIndex] : babylonMaterial;\n            if (babylonMaterial instanceof _babylonjs_core_Materials_PBR_pbrBaseMaterial_js__WEBPACK_IMPORTED_MODULE_16__.PBRBaseMaterial) {\n                materialIndex = await this._materialExporter.exportPBRMaterialAsync(babylonMaterial, hasUVs);\n            }\n            else if (babylonMaterial instanceof _babylonjs_core_Materials_standardMaterial_js__WEBPACK_IMPORTED_MODULE_17__.StandardMaterial) {\n                materialIndex = await this._materialExporter.exportStandardMaterialAsync(babylonMaterial, hasUVs);\n            }\n            else if (babylonMaterial instanceof _babylonjs_core_Materials_PBR_openpbrMaterial_js__WEBPACK_IMPORTED_MODULE_28__.OpenPBRMaterial) {\n                materialIndex = await this._materialExporter.exportOpenPBRMaterialAsync(babylonMaterial, hasUVs);\n            }\n            else {\n                _babylonjs_core_Misc_logger_js__WEBPACK_IMPORTED_MODULE_18__.Logger.Warn(`Unsupported material '${babylonMaterial.name}' with type ${babylonMaterial.getClassName()}`);\n                return;\n            }\n            this._materialMap.set(babylonMaterial, materialIndex);\n        }\n        primitive.material = materialIndex;\n    }\n    async _exportMeshAsync(babylonMesh, state) {\n        let meshIndex = state.getMesh(babylonMesh);\n        if (meshIndex !== undefined) {\n            return meshIndex;\n        }\n        const mesh = { primitives: [] };\n        meshIndex = this._meshes.length;\n        this._meshes.push(mesh);\n        state.setMesh(babylonMesh, meshIndex);\n        const indices = babylonMesh.isUnIndexed ? null : babylonMesh.getIndices();\n        const vertexBuffers = babylonMesh.geometry?.getVertexBuffers();\n        const morphTargets = state.getMorphTargetsFromMesh(babylonMesh);\n        const isLinesMesh = babylonMesh instanceof _babylonjs_core_Meshes_linesMesh_js__WEBPACK_IMPORTED_MODULE_22__.LinesMesh;\n        const isGreasedLineMesh = babylonMesh instanceof _babylonjs_core_Meshes_GreasedLine_greasedLineBaseMesh_js__WEBPACK_IMPORTED_MODULE_23__.GreasedLineBaseMesh;\n        const subMeshes = babylonMesh.subMeshes;\n        if (vertexBuffers && subMeshes && subMeshes.length > 0) {\n            for (const subMesh of subMeshes) {\n                const primitive = { attributes: {} };\n                const babylonMaterial = subMesh.getMaterial() || this._babylonScene.defaultMaterial;\n                if (isGreasedLineMesh) {\n                    const material = {\n                        name: babylonMaterial.name,\n                    };\n                    const babylonLinesMesh = babylonMesh;\n                    const colorWhite = _babylonjs_core_Maths_math_color_js__WEBPACK_IMPORTED_MODULE_24__.Color3.White();\n                    const alpha = babylonLinesMesh.material?.alpha ?? 1;\n                    const color = babylonLinesMesh.greasedLineMaterial?.color ?? colorWhite;\n                    if (!color.equalsWithEpsilon(colorWhite, _babylonjs_core_Maths_math_constants_js__WEBPACK_IMPORTED_MODULE_26__.Epsilon) || alpha < 1) {\n                        material.pbrMetallicRoughness = {\n                            baseColorFactor: [...color.asArray(), alpha],\n                        };\n                    }\n                    this._materials.push(material);\n                    primitive.material = this._materials.length - 1;\n                }\n                else if (isLinesMesh) {\n                    // Special case for LinesMesh\n                    const material = {\n                        name: babylonMaterial.name,\n                    };\n                    const babylonLinesMesh = babylonMesh;\n                    if (!babylonLinesMesh.color.equalsWithEpsilon(_babylonjs_core_Maths_math_color_js__WEBPACK_IMPORTED_MODULE_24__.Color3.White(), _babylonjs_core_Maths_math_constants_js__WEBPACK_IMPORTED_MODULE_26__.Epsilon) || babylonLinesMesh.alpha < 1) {\n                        material.pbrMetallicRoughness = {\n                            baseColorFactor: [...babylonLinesMesh.color.asArray(), babylonLinesMesh.alpha],\n                        };\n                    }\n                    this._materials.push(material);\n                    primitive.material = this._materials.length - 1;\n                }\n                else {\n                    // Material\n                    // eslint-disable-next-line no-await-in-loop\n                    await this._exportMaterialAsync(babylonMaterial, vertexBuffers, subMesh, primitive);\n                }\n                // Index buffer\n                const fillMode = isLinesMesh || isGreasedLineMesh ? _babylonjs_core_Materials_material_js__WEBPACK_IMPORTED_MODULE_6__.Material.LineListDrawMode : (babylonMesh.overrideRenderingFillMode ?? babylonMaterial.fillMode);\n                let sideOrientation = babylonMaterial._getEffectiveOrientation(babylonMesh);\n                if (state.wasAddedByNoopNode && !babylonMesh.getScene().useRightHandedSystem) {\n                    // To properly remove a conversion node, we must also cancel out the implicit flip in its children's side orientations.\n                    sideOrientation = sideOrientation === _babylonjs_core_Materials_material_js__WEBPACK_IMPORTED_MODULE_6__.Material.ClockWiseSideOrientation ? _babylonjs_core_Materials_material_js__WEBPACK_IMPORTED_MODULE_6__.Material.CounterClockWiseSideOrientation : _babylonjs_core_Materials_material_js__WEBPACK_IMPORTED_MODULE_6__.Material.ClockWiseSideOrientation;\n                }\n                this._exportIndices(indices, indices ? (0,_babylonjs_core_Buffers_bufferUtils_js__WEBPACK_IMPORTED_MODULE_19__.AreIndices32Bits)(indices, subMesh.indexCount, subMesh.indexStart, subMesh.verticesStart) : subMesh.verticesCount > 65535, indices ? subMesh.indexStart : subMesh.verticesStart, indices ? subMesh.indexCount : subMesh.verticesCount, -subMesh.verticesStart, fillMode, sideOrientation, state, primitive);\n                // Vertex buffers\n                for (const vertexBuffer of Object.values(vertexBuffers)) {\n                    this._exportVertexBuffer(vertexBuffer, babylonMaterial, subMesh.verticesStart, subMesh.verticesCount, state, primitive);\n                }\n                if (morphTargets) {\n                    primitive.targets = [];\n                    for (const gltfMorphTarget of morphTargets) {\n                        primitive.targets.push(gltfMorphTarget.attributes);\n                    }\n                }\n                mesh.primitives.push(primitive);\n                this._extensionsPostExportMeshPrimitive(primitive);\n            }\n        }\n        if (morphTargets) {\n            mesh.weights = [];\n            if (!mesh.extras) {\n                mesh.extras = {};\n            }\n            mesh.extras.targetNames = [];\n            for (const gltfMorphTarget of morphTargets) {\n                mesh.weights.push(gltfMorphTarget.influence);\n                mesh.extras.targetNames.push(gltfMorphTarget.name);\n            }\n        }\n        return meshIndex;\n    }\n}\nGLTFExporter._ExtensionNames = new Array();\nGLTFExporter._ExtensionFactories = {};\nGLTFExporter._ExtensionOrders = {};\n//# sourceMappingURL=glTFExporter.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/serializers/glTF/2.0/glTFExporter.js?\n}");

/***/ },

/***/ "./node_modules/@babylonjs/serializers/glTF/2.0/glTFMaterialExporter.js"
/*!******************************************************************************!*\
  !*** ./node_modules/@babylonjs/serializers/glTF/2.0/glTFMaterialExporter.js ***!
  \******************************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLTFMaterialExporter: () => (/* binding */ GLTFMaterialExporter),\n/* harmony export */   _ConvertToGLTFPBRMetallicRoughness: () => (/* binding */ _ConvertToGLTFPBRMetallicRoughness),\n/* harmony export */   _SolveMetallic: () => (/* binding */ _SolveMetallic)\n/* harmony export */ });\n/* harmony import */ var _babylonjs_core_Maths_math_color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babylonjs/core/Maths/math.color.js */ \"./node_modules/@babylonjs/core/Maths/math.color.js\");\n/* harmony import */ var _babylonjs_core_Maths_math_scalar_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babylonjs/core/Maths/math.scalar.js */ \"./node_modules/@babylonjs/core/Maths/math.scalar.js\");\n/* harmony import */ var _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babylonjs/core/Misc/tools.js */ \"./node_modules/@babylonjs/core/Misc/tools.js\");\n/* harmony import */ var _babylonjs_core_Misc_textureTools_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babylonjs/core/Misc/textureTools.js */ \"./node_modules/@babylonjs/core/Misc/textureTools.js\");\n/* harmony import */ var _babylonjs_core_Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babylonjs/core/Materials/Textures/texture.js */ \"./node_modules/@babylonjs/core/Materials/Textures/texture.js\");\n/* harmony import */ var _babylonjs_core_Materials_Textures_rawTexture_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babylonjs/core/Materials/Textures/rawTexture.js */ \"./node_modules/@babylonjs/core/Materials/Textures/rawTexture.js\");\n/* harmony import */ var _babylonjs_core_Engines_constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babylonjs/core/Engines/constants.js */ \"./node_modules/@babylonjs/core/Engines/constants.js\");\n/* harmony import */ var _babylonjs_core_Misc_dumpTools_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babylonjs/core/Misc/dumpTools.js */ \"./node_modules/@babylonjs/core/Misc/dumpTools.js\");\n/* harmony import */ var _babylonjs_core_Materials_PBR_pbrBaseMaterial_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @babylonjs/core/Materials/PBR/pbrBaseMaterial.js */ \"./node_modules/@babylonjs/core/Materials/PBR/pbrBaseMaterial.js\");\n/* harmony import */ var _babylonjs_core_Helpers_materialConversionHelper_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @babylonjs/core/Helpers/materialConversionHelper.js */ \"./node_modules/@babylonjs/core/Helpers/materialConversionHelper.js\");\n/* harmony import */ var _babylonjs_core_Misc_fileTools_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @babylonjs/core/Misc/fileTools.js */ \"./node_modules/@babylonjs/core/Misc/fileTools.js\");\n/* harmony import */ var _babylonjs_core_Materials_PBR_openpbrMaterial_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @babylonjs/core/Materials/PBR/openpbrMaterial.js */ \"./node_modules/@babylonjs/core/Materials/PBR/openpbrMaterial.js\");\n/* harmony import */ var _babylonjs_core_Materials_Textures_textureMerger_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @babylonjs/core/Materials/Textures/textureMerger.js */ \"./node_modules/@babylonjs/core/Materials/Textures/textureMerger.js\");\n/* eslint-disable @typescript-eslint/prefer-promise-reject-errors */\n/* eslint-disable github/no-then */\n/* eslint-disable babylonjs/available */\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst Epsilon = 1e-6;\nconst DielectricSpecular = new _babylonjs_core_Maths_math_color_js__WEBPACK_IMPORTED_MODULE_0__.Color3(0.04, 0.04, 0.04);\nconst MaxSpecularPower = 1024;\nconst White = _babylonjs_core_Maths_math_color_js__WEBPACK_IMPORTED_MODULE_0__.Color3.White();\nconst Black = _babylonjs_core_Maths_math_color_js__WEBPACK_IMPORTED_MODULE_0__.Color3.BlackReadOnly;\nfunction GetFileExtensionFromMimeType(mimeType) {\n    switch (mimeType) {\n        case \"image/jpeg\" /* ImageMimeType.JPEG */:\n            return \".jpg\";\n        case \"image/png\" /* ImageMimeType.PNG */:\n            return \".png\";\n        case \"image/webp\" /* ImageMimeType.WEBP */:\n            return \".webp\";\n        case \"image/avif\" /* ImageMimeType.AVIF */:\n            return \".avif\";\n        case \"image/ktx2\" /* ImageMimeType.KTX2 */:\n            return \".ktx2\";\n    }\n}\n/**\n * @param mimeType the MIME type requested by the user\n * @returns true if the given mime type is compatible with glTF\n */\nfunction IsSupportedMimeType(mimeType) {\n    switch (mimeType) {\n        case \"image/jpeg\" /* ImageMimeType.JPEG */:\n        case \"image/png\" /* ImageMimeType.PNG */:\n        case \"image/webp\" /* ImageMimeType.WEBP */:\n        case \"image/avif\" /* ImageMimeType.AVIF */:\n        case \"image/ktx2\" /* ImageMimeType.KTX2 */:\n            return true;\n        default:\n            return false;\n    }\n}\n/**\n * Gets cached image from a texture, if available.\n * @param babylonTexture texture to check for cached image\n * @returns image data if found and directly usable; null otherwise\n */\nasync function GetCachedImageAsync(babylonTexture) {\n    const internalTexture = babylonTexture.getInternalTexture();\n    if (!internalTexture || internalTexture.source !== 1 /* InternalTextureSource.Url */) {\n        return null;\n    }\n    if (internalTexture.invertY) {\n        return null;\n    }\n    const buffer = internalTexture._buffer;\n    let data;\n    let mimeType = babylonTexture.mimeType;\n    try {\n        if (!buffer) {\n            data = await _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_2__.Tools.LoadFileAsync(internalTexture.url);\n            mimeType = (0,_babylonjs_core_Misc_fileTools_js__WEBPACK_IMPORTED_MODULE_10__.GetMimeType)(internalTexture.url) || mimeType;\n        }\n        else if (ArrayBuffer.isView(buffer)) {\n            data = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\n        }\n        else if (buffer instanceof ArrayBuffer) {\n            data = buffer;\n        }\n        else if (buffer instanceof Blob) {\n            data = await buffer.arrayBuffer();\n            mimeType = buffer.type || mimeType;\n        }\n        else if (typeof buffer === \"string\") {\n            data = await _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_2__.Tools.LoadFileAsync(buffer);\n            mimeType = (0,_babylonjs_core_Misc_fileTools_js__WEBPACK_IMPORTED_MODULE_10__.GetMimeType)(buffer) || mimeType;\n        }\n        else if (typeof HTMLImageElement !== \"undefined\" && buffer instanceof HTMLImageElement) {\n            data = await _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_2__.Tools.LoadFileAsync(buffer.src);\n            mimeType = (0,_babylonjs_core_Misc_fileTools_js__WEBPACK_IMPORTED_MODULE_10__.GetMimeType)(buffer.src) || mimeType;\n        }\n    }\n    catch {\n        // Failed to load texture data, fall back to GPU texture read via GetTextureDataAsync\n        return null;\n    }\n    if (data && IsSupportedMimeType(mimeType)) {\n        return new Blob([data], { type: mimeType });\n    }\n    return null;\n}\n/**\n * Computes the metallic factor from specular glossiness values.\n * @param diffuse diffused value\n * @param specular specular value\n * @param oneMinusSpecularStrength one minus the specular strength\n * @returns metallic value\n * @internal\n */\nfunction _SolveMetallic(diffuse, specular, oneMinusSpecularStrength) {\n    if (specular < DielectricSpecular.r) {\n        return 0;\n    }\n    const a = DielectricSpecular.r;\n    const b = (diffuse * oneMinusSpecularStrength) / (1.0 - DielectricSpecular.r) + specular - 2.0 * DielectricSpecular.r;\n    const c = DielectricSpecular.r - specular;\n    const d = b * b - 4.0 * a * c;\n    return _babylonjs_core_Maths_math_scalar_js__WEBPACK_IMPORTED_MODULE_1__.Scalar.Clamp((-b + Math.sqrt(d)) / (2.0 * a), 0, 1);\n}\n/**\n * Computes the metallic/roughness factors from a Standard Material.\n * @internal\n */\nfunction _ConvertToGLTFPBRMetallicRoughness(babylonStandardMaterial) {\n    const diffuse = babylonStandardMaterial.diffuseColor.toLinearSpace(babylonStandardMaterial.getScene().getEngine().useExactSrgbConversions).scale(0.5);\n    const opacity = babylonStandardMaterial.alpha;\n    const specularPower = _babylonjs_core_Maths_math_scalar_js__WEBPACK_IMPORTED_MODULE_1__.Scalar.Clamp(babylonStandardMaterial.specularPower, 0, MaxSpecularPower);\n    const roughness = (0,_babylonjs_core_Helpers_materialConversionHelper_js__WEBPACK_IMPORTED_MODULE_9__.SpecularPowerToRoughness)(specularPower);\n    const glTFPbrMetallicRoughness = {\n        baseColorFactor: [diffuse.r, diffuse.g, diffuse.b, opacity],\n        metallicFactor: 0,\n        roughnessFactor: roughness,\n    };\n    return glTFPbrMetallicRoughness;\n}\n/**\n * Sets the glTF alpha mode to a glTF material from the Babylon Material\n * @param glTFMaterial glTF material\n * @param babylonMaterial Babylon material\n */\nfunction SetAlphaMode(glTFMaterial, babylonMaterial) {\n    if (babylonMaterial.needAlphaBlending()) {\n        glTFMaterial.alphaMode = \"BLEND\" /* MaterialAlphaMode.BLEND */;\n    }\n    else if (babylonMaterial.needAlphaTesting()) {\n        glTFMaterial.alphaMode = \"MASK\" /* MaterialAlphaMode.MASK */;\n        glTFMaterial.alphaCutoff = babylonMaterial.alphaCutOff;\n    }\n}\nfunction CreateWhiteTexture(width, height, scene) {\n    const data = new Uint8Array(width * height * 4);\n    for (let i = 0; i < data.length; i = i + 4) {\n        data[i] = data[i + 1] = data[i + 2] = data[i + 3] = 0xff;\n    }\n    const rawTexture = _babylonjs_core_Materials_Textures_rawTexture_js__WEBPACK_IMPORTED_MODULE_5__.RawTexture.CreateRGBATexture(data, width, height, scene);\n    return rawTexture;\n}\nfunction ConvertPixelArrayToFloat32(pixels) {\n    if (pixels instanceof Uint8Array) {\n        const length = pixels.length;\n        const buffer = new Float32Array(pixels.length);\n        for (let i = 0; i < length; ++i) {\n            buffer[i] = pixels[i] / 255;\n        }\n        return buffer;\n    }\n    else if (pixels instanceof Float32Array) {\n        return pixels;\n    }\n    else {\n        throw new Error(\"Unsupported pixel format!\");\n    }\n}\n/**\n * Utility methods for working with glTF material conversion properties.\n * @internal\n */\nclass GLTFMaterialExporter {\n    constructor(_exporter) {\n        this._exporter = _exporter;\n        // Mapping to store textures\n        this._textureMap = new Map();\n        // Mapping of internal textures to images to avoid exporting duplicate images\n        this._internalTextureToImage = {};\n    }\n    getTextureInfo(babylonTexture) {\n        return babylonTexture ? (this._textureMap.get(babylonTexture.uniqueId) ?? null) : null;\n    }\n    async exportStandardMaterialAsync(babylonStandardMaterial, hasUVs) {\n        const pbrMetallicRoughness = _ConvertToGLTFPBRMetallicRoughness(babylonStandardMaterial);\n        const material = { name: babylonStandardMaterial.name };\n        if (babylonStandardMaterial.backFaceCulling != null && !babylonStandardMaterial.backFaceCulling) {\n            if (!babylonStandardMaterial.twoSidedLighting) {\n                _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_2__.Tools.Warn(babylonStandardMaterial.name + \": Back-face culling disabled and two-sided lighting disabled is not supported in glTF.\");\n            }\n            material.doubleSided = true;\n        }\n        if (hasUVs) {\n            const promises = [];\n            const diffuseTexture = babylonStandardMaterial.diffuseTexture;\n            if (diffuseTexture) {\n                promises.push(this.exportTextureAsync(diffuseTexture).then((textureInfo) => {\n                    if (textureInfo) {\n                        pbrMetallicRoughness.baseColorTexture = textureInfo;\n                    }\n                }));\n            }\n            const bumpTexture = babylonStandardMaterial.bumpTexture;\n            if (bumpTexture) {\n                promises.push(this.exportTextureAsync(bumpTexture).then((textureInfo) => {\n                    if (textureInfo) {\n                        material.normalTexture = textureInfo;\n                        if (bumpTexture.level !== 1) {\n                            material.normalTexture.scale = bumpTexture.level;\n                        }\n                    }\n                }));\n            }\n            const emissiveTexture = babylonStandardMaterial.emissiveTexture;\n            if (emissiveTexture) {\n                material.emissiveFactor = [1.0, 1.0, 1.0];\n                promises.push(this.exportTextureAsync(emissiveTexture).then((textureInfo) => {\n                    if (textureInfo) {\n                        material.emissiveTexture = textureInfo;\n                    }\n                }));\n            }\n            const ambientTexture = babylonStandardMaterial.ambientTexture;\n            if (ambientTexture) {\n                promises.push(this.exportTextureAsync(ambientTexture).then((textureInfo) => {\n                    if (textureInfo) {\n                        const occlusionTexture = {\n                            index: textureInfo.index,\n                        };\n                        material.occlusionTexture = occlusionTexture;\n                    }\n                }));\n            }\n            if (promises.length > 0) {\n                this._exporter._materialNeedsUVsSet.add(babylonStandardMaterial);\n                await Promise.all(promises);\n            }\n        }\n        if (babylonStandardMaterial.alpha < 1.0 || babylonStandardMaterial.opacityTexture) {\n            if (babylonStandardMaterial.alphaMode === _babylonjs_core_Engines_constants_js__WEBPACK_IMPORTED_MODULE_6__.Constants.ALPHA_COMBINE) {\n                material.alphaMode = \"BLEND\" /* MaterialAlphaMode.BLEND */;\n            }\n            else {\n                _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_2__.Tools.Warn(babylonStandardMaterial.name + \": glTF 2.0 does not support alpha mode: \" + babylonStandardMaterial.alphaMode.toString());\n            }\n        }\n        if (babylonStandardMaterial.emissiveColor && !babylonStandardMaterial.emissiveColor.equalsWithEpsilon(Black, Epsilon)) {\n            material.emissiveFactor = babylonStandardMaterial.emissiveColor.asArray();\n        }\n        material.pbrMetallicRoughness = pbrMetallicRoughness;\n        SetAlphaMode(material, babylonStandardMaterial);\n        await this._finishMaterialAsync(material, babylonStandardMaterial);\n        const materials = this._exporter._materials;\n        materials.push(material);\n        return materials.length - 1;\n    }\n    async _finishMaterialAsync(glTFMaterial, babylonMaterial) {\n        const textures = await this._exporter._extensionsPostExportMaterialAdditionalTexturesAsync(\"exportMaterial\", glTFMaterial, babylonMaterial);\n        const promises = [];\n        for (const texture of textures) {\n            promises.push(this.exportTextureAsync(texture));\n        }\n        await Promise.all(promises);\n        await this._exporter._extensionsPostExportMaterialAsync(\"exportMaterial\", glTFMaterial, babylonMaterial);\n    }\n    /**\n     * Resizes the two source textures to the same dimensions.  If a texture is null, a default white texture is generated.  If both textures are null, returns null\n     * @param texture1 first texture to resize\n     * @param texture2 second texture to resize\n     * @param scene babylonjs scene\n     * @returns resized textures or null\n     */\n    _resizeTexturesToSameDimensions(texture1, texture2, scene) {\n        const texture1Size = texture1 ? texture1.getSize() : { width: 0, height: 0 };\n        const texture2Size = texture2 ? texture2.getSize() : { width: 0, height: 0 };\n        let resizedTexture1;\n        let resizedTexture2;\n        if (texture1Size.width < texture2Size.width) {\n            if (texture1 && texture1 instanceof _babylonjs_core_Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_4__.Texture) {\n                resizedTexture1 = _babylonjs_core_Misc_textureTools_js__WEBPACK_IMPORTED_MODULE_3__.TextureTools.CreateResizedCopy(texture1, texture2Size.width, texture2Size.height, true);\n            }\n            else {\n                resizedTexture1 = CreateWhiteTexture(texture2Size.width, texture2Size.height, scene);\n            }\n            resizedTexture2 = texture2;\n        }\n        else if (texture1Size.width > texture2Size.width) {\n            if (texture2 && texture2 instanceof _babylonjs_core_Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_4__.Texture) {\n                resizedTexture2 = _babylonjs_core_Misc_textureTools_js__WEBPACK_IMPORTED_MODULE_3__.TextureTools.CreateResizedCopy(texture2, texture1Size.width, texture1Size.height, true);\n            }\n            else {\n                resizedTexture2 = CreateWhiteTexture(texture1Size.width, texture1Size.height, scene);\n            }\n            resizedTexture1 = texture1;\n        }\n        else {\n            resizedTexture1 = texture1;\n            resizedTexture2 = texture2;\n        }\n        return {\n            texture1: resizedTexture1,\n            texture2: resizedTexture2,\n        };\n    }\n    /**\n     * Convert Specular Glossiness Textures to Metallic Roughness\n     * See link below for info on the material conversions from PBR Metallic/Roughness and Specular/Glossiness\n     * @see https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness/examples/convert-between-workflows-.js/babylon.pbrUtilities.js\n     * @param diffuseTexture texture used to store diffuse information\n     * @param specularGlossinessTexture texture used to store specular and glossiness information\n     * @param factors specular glossiness material factors\n     * @returns pbr metallic roughness interface or null\n     */\n    async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(diffuseTexture, specularGlossinessTexture, factors) {\n        const promises = new Array();\n        if (!(diffuseTexture || specularGlossinessTexture)) {\n            return await Promise.reject(\"diffuse and specular glossiness textures are not defined!\");\n        }\n        const scene = diffuseTexture ? diffuseTexture.getScene() : specularGlossinessTexture ? specularGlossinessTexture.getScene() : null;\n        if (scene) {\n            const resizedTextures = this._resizeTexturesToSameDimensions(diffuseTexture, specularGlossinessTexture, scene);\n            const diffuseSize = resizedTextures.texture1?.getSize();\n            let diffuseBuffer;\n            let specularGlossinessBuffer;\n            const width = diffuseSize.width;\n            const height = diffuseSize.height;\n            const diffusePixels = await resizedTextures.texture1.readPixels();\n            const specularPixels = await resizedTextures.texture2.readPixels();\n            if (diffusePixels) {\n                diffuseBuffer = ConvertPixelArrayToFloat32(diffusePixels);\n            }\n            else {\n                return await Promise.reject(\"Failed to retrieve pixels from diffuse texture!\");\n            }\n            if (specularPixels) {\n                specularGlossinessBuffer = ConvertPixelArrayToFloat32(specularPixels);\n            }\n            else {\n                return await Promise.reject(\"Failed to retrieve pixels from specular glossiness texture!\");\n            }\n            const byteLength = specularGlossinessBuffer.byteLength;\n            const metallicRoughnessBuffer = new Uint8Array(byteLength);\n            const baseColorBuffer = new Uint8Array(byteLength);\n            const strideSize = 4;\n            const maxBaseColor = new _babylonjs_core_Maths_math_color_js__WEBPACK_IMPORTED_MODULE_0__.Color3(0, 0, 0);\n            let maxMetallic = 0;\n            let maxRoughness = 0;\n            for (let h = 0; h < height; ++h) {\n                for (let w = 0; w < width; ++w) {\n                    const offset = (width * h + w) * strideSize;\n                    const diffuseColor = new _babylonjs_core_Maths_math_color_js__WEBPACK_IMPORTED_MODULE_0__.Color3(diffuseBuffer[offset], diffuseBuffer[offset + 1], diffuseBuffer[offset + 2])\n                        .toLinearSpace(scene.getEngine().useExactSrgbConversions)\n                        .multiply(factors.diffuseColor);\n                    const specularColor = new _babylonjs_core_Maths_math_color_js__WEBPACK_IMPORTED_MODULE_0__.Color3(specularGlossinessBuffer[offset], specularGlossinessBuffer[offset + 1], specularGlossinessBuffer[offset + 2])\n                        .toLinearSpace(scene.getEngine().useExactSrgbConversions)\n                        .multiply(factors.specularColor);\n                    const glossiness = specularGlossinessBuffer[offset + 3] * factors.glossiness;\n                    const specularGlossiness = {\n                        diffuseColor: diffuseColor,\n                        specularColor: specularColor,\n                        glossiness: glossiness,\n                    };\n                    const metallicRoughness = this._convertSpecularGlossinessToMetallicRoughness(specularGlossiness);\n                    maxBaseColor.r = Math.max(maxBaseColor.r, metallicRoughness.baseColor.r);\n                    maxBaseColor.g = Math.max(maxBaseColor.g, metallicRoughness.baseColor.g);\n                    maxBaseColor.b = Math.max(maxBaseColor.b, metallicRoughness.baseColor.b);\n                    maxMetallic = Math.max(maxMetallic, metallicRoughness.metallic);\n                    maxRoughness = Math.max(maxRoughness, metallicRoughness.roughness);\n                    baseColorBuffer[offset] = metallicRoughness.baseColor.r * 255;\n                    baseColorBuffer[offset + 1] = metallicRoughness.baseColor.g * 255;\n                    baseColorBuffer[offset + 2] = metallicRoughness.baseColor.b * 255;\n                    baseColorBuffer[offset + 3] = resizedTextures.texture1.hasAlpha ? diffuseBuffer[offset + 3] * 255 : 255;\n                    metallicRoughnessBuffer[offset] = 0;\n                    metallicRoughnessBuffer[offset + 1] = metallicRoughness.roughness * 255;\n                    metallicRoughnessBuffer[offset + 2] = metallicRoughness.metallic * 255;\n                    metallicRoughnessBuffer[offset + 3] = 255;\n                }\n            }\n            // Retrieves the metallic roughness factors from the maximum texture values.\n            const metallicRoughnessFactors = {\n                baseColor: maxBaseColor,\n                metallic: maxMetallic,\n                roughness: maxRoughness,\n            };\n            let writeOutMetallicRoughnessTexture = false;\n            let writeOutBaseColorTexture = false;\n            for (let h = 0; h < height; ++h) {\n                for (let w = 0; w < width; ++w) {\n                    const destinationOffset = (width * h + w) * strideSize;\n                    baseColorBuffer[destinationOffset] /= metallicRoughnessFactors.baseColor.r > Epsilon ? metallicRoughnessFactors.baseColor.r : 1;\n                    baseColorBuffer[destinationOffset + 1] /= metallicRoughnessFactors.baseColor.g > Epsilon ? metallicRoughnessFactors.baseColor.g : 1;\n                    baseColorBuffer[destinationOffset + 2] /= metallicRoughnessFactors.baseColor.b > Epsilon ? metallicRoughnessFactors.baseColor.b : 1;\n                    const linearBaseColorPixel = _babylonjs_core_Maths_math_color_js__WEBPACK_IMPORTED_MODULE_0__.Color3.FromInts(baseColorBuffer[destinationOffset], baseColorBuffer[destinationOffset + 1], baseColorBuffer[destinationOffset + 2]);\n                    const sRGBBaseColorPixel = linearBaseColorPixel.toGammaSpace(scene.getEngine().useExactSrgbConversions);\n                    baseColorBuffer[destinationOffset] = sRGBBaseColorPixel.r * 255;\n                    baseColorBuffer[destinationOffset + 1] = sRGBBaseColorPixel.g * 255;\n                    baseColorBuffer[destinationOffset + 2] = sRGBBaseColorPixel.b * 255;\n                    if (!sRGBBaseColorPixel.equalsWithEpsilon(White, Epsilon)) {\n                        writeOutBaseColorTexture = true;\n                    }\n                    metallicRoughnessBuffer[destinationOffset + 1] /= metallicRoughnessFactors.roughness > Epsilon ? metallicRoughnessFactors.roughness : 1;\n                    metallicRoughnessBuffer[destinationOffset + 2] /= metallicRoughnessFactors.metallic > Epsilon ? metallicRoughnessFactors.metallic : 1;\n                    const metallicRoughnessPixel = _babylonjs_core_Maths_math_color_js__WEBPACK_IMPORTED_MODULE_0__.Color3.FromInts(255, metallicRoughnessBuffer[destinationOffset + 1], metallicRoughnessBuffer[destinationOffset + 2]);\n                    if (!metallicRoughnessPixel.equalsWithEpsilon(White, Epsilon)) {\n                        writeOutMetallicRoughnessTexture = true;\n                    }\n                }\n            }\n            if (writeOutMetallicRoughnessTexture) {\n                promises.push((0,_babylonjs_core_Misc_dumpTools_js__WEBPACK_IMPORTED_MODULE_7__.EncodeImageAsync)(metallicRoughnessBuffer, width, height).then((data) => {\n                    metallicRoughnessFactors.metallicRoughnessTextureData = data;\n                }));\n            }\n            if (writeOutBaseColorTexture) {\n                promises.push((0,_babylonjs_core_Misc_dumpTools_js__WEBPACK_IMPORTED_MODULE_7__.EncodeImageAsync)(baseColorBuffer, width, height).then((data) => {\n                    metallicRoughnessFactors.baseColorTextureData = data;\n                }));\n            }\n            return await Promise.all(promises).then(() => {\n                return metallicRoughnessFactors;\n            });\n        }\n        else {\n            return await Promise.reject(\"_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!\");\n        }\n    }\n    /**\n     * Converts specular glossiness material properties to metallic roughness\n     * @param specularGlossiness interface with specular glossiness material properties\n     * @returns interface with metallic roughness material properties\n     */\n    _convertSpecularGlossinessToMetallicRoughness(specularGlossiness) {\n        const diffusePerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.diffuseColor);\n        const specularPerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.specularColor);\n        const oneMinusSpecularStrength = 1 - this._getMaxComponent(specularGlossiness.specularColor);\n        const metallic = _SolveMetallic(diffusePerceivedBrightness, specularPerceivedBrightness, oneMinusSpecularStrength);\n        const baseColorFromDiffuse = specularGlossiness.diffuseColor.scale(oneMinusSpecularStrength / (1.0 - DielectricSpecular.r) / Math.max(1 - metallic, Epsilon));\n        const baseColorFromSpecular = specularGlossiness.specularColor.subtract(DielectricSpecular.scale(1 - metallic)).scale(1 / Math.max(metallic, Epsilon));\n        let baseColor = _babylonjs_core_Maths_math_color_js__WEBPACK_IMPORTED_MODULE_0__.Color3.Lerp(baseColorFromDiffuse, baseColorFromSpecular, metallic * metallic);\n        baseColor = baseColor.clampToRef(0, 1, baseColor);\n        const metallicRoughness = {\n            baseColor: baseColor,\n            metallic: metallic,\n            roughness: 1 - specularGlossiness.glossiness,\n        };\n        return metallicRoughness;\n    }\n    /**\n     * Calculates the surface reflectance, independent of lighting conditions\n     * @param color Color source to calculate brightness from\n     * @returns number representing the perceived brightness, or zero if color is undefined\n     */\n    _getPerceivedBrightness(color) {\n        return Math.sqrt(0.299 * color.r * color.r + 0.587 * color.g * color.g + 0.114 * color.b * color.b);\n    }\n    /**\n     * Returns the maximum color component value\n     * @param color\n     * @returns maximum color component value, or zero if color is null or undefined\n     */\n    _getMaxComponent(color) {\n        return Math.max(color.r, Math.max(color.g, color.b));\n    }\n    /**\n     * Convert a PBRMaterial (Metallic/Roughness) to Metallic Roughness factors\n     * @param baseColor Base color of the material\n     * @param metallic Metallic factor of the material\n     * @param roughness Roughness factor of the material\n     * @param albedoTexture Albedo texture of the material\n     * @param metallicTexture Metallic texture of the material\n     * @param roughnessTexture Roughness texture of the material\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\n     * @param glTFPbrMetallicRoughness glTF PBR Metallic Roughness interface\n     * @param hasUVs specifies if texture coordinates are present on the submesh to determine if textures should be applied\n     * @returns glTF PBR Metallic Roughness factors\n     */\n    async _convertMetalRoughFactorsToMetallicRoughnessAsync(baseColor, metallic, roughness, albedoTexture, metallicTexture, roughnessTexture, babylonPBRMaterial, glTFPbrMetallicRoughness, hasUVs) {\n        const promises = [];\n        const metallicRoughness = {\n            baseColor: baseColor,\n            metallic: metallic,\n            roughness: roughness,\n        };\n        if (hasUVs) {\n            if (babylonPBRMaterial instanceof _babylonjs_core_Materials_PBR_openpbrMaterial_js__WEBPACK_IMPORTED_MODULE_11__.OpenPBRMaterial) {\n                if (babylonPBRMaterial.geometryOpacityTexture) {\n                    // Merge baseColor and opacity\n                    const albedoId = albedoTexture && albedoTexture.getInternalTexture() ? albedoTexture.getInternalTexture().uniqueId : 0;\n                    const opacityId = babylonPBRMaterial.geometryOpacityTexture && babylonPBRMaterial.geometryOpacityTexture.getInternalTexture()\n                        ? babylonPBRMaterial.geometryOpacityTexture.getInternalTexture().uniqueId\n                        : 0;\n                    const mergedId = Number(`${albedoId}${opacityId}`);\n                    const glTFTexture = this._textureMap.get(mergedId);\n                    if (glTFTexture) {\n                        glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\n                    }\n                    else {\n                        promises.push((0,_babylonjs_core_Materials_Textures_textureMerger_js__WEBPACK_IMPORTED_MODULE_12__.MergeTexturesAsync)(\"baseColorOpacityTexture\", (0,_babylonjs_core_Materials_Textures_textureMerger_js__WEBPACK_IMPORTED_MODULE_12__.CreateRGBAConfiguration)(albedoTexture ? (0,_babylonjs_core_Materials_Textures_textureMerger_js__WEBPACK_IMPORTED_MODULE_12__.CreateTextureInput)(albedoTexture, 0) : (0,_babylonjs_core_Materials_Textures_textureMerger_js__WEBPACK_IMPORTED_MODULE_12__.CreateConstantInput)(1.0), albedoTexture ? (0,_babylonjs_core_Materials_Textures_textureMerger_js__WEBPACK_IMPORTED_MODULE_12__.CreateTextureInput)(albedoTexture, 1) : (0,_babylonjs_core_Materials_Textures_textureMerger_js__WEBPACK_IMPORTED_MODULE_12__.CreateConstantInput)(1.0), albedoTexture ? (0,_babylonjs_core_Materials_Textures_textureMerger_js__WEBPACK_IMPORTED_MODULE_12__.CreateTextureInput)(albedoTexture, 2) : (0,_babylonjs_core_Materials_Textures_textureMerger_js__WEBPACK_IMPORTED_MODULE_12__.CreateConstantInput)(1.0), (0,_babylonjs_core_Materials_Textures_textureMerger_js__WEBPACK_IMPORTED_MODULE_12__.CreateTextureInput)(babylonPBRMaterial.geometryOpacityTexture, 0)), babylonPBRMaterial.getScene()).then(async (mergedTexture) => {\n                            const glTFTexture = await this.exportTextureAsync(mergedTexture, mergedId);\n                            if (glTFTexture) {\n                                glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\n                            }\n                        }));\n                    }\n                }\n                else {\n                    if (albedoTexture) {\n                        promises.push(this.exportTextureAsync(albedoTexture).then((glTFTexture) => {\n                            if (glTFTexture) {\n                                glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\n                            }\n                        }));\n                    }\n                }\n                if (babylonPBRMaterial._useMetallicFromMetallicTextureBlue && metallicTexture) {\n                    promises.push(this.exportTextureAsync(metallicTexture).then((glTFTexture) => {\n                        if (glTFTexture) {\n                            glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFTexture;\n                        }\n                    }));\n                }\n                else if (roughnessTexture || metallicTexture) {\n                    const metallicId = metallicTexture && metallicTexture.getInternalTexture() ? metallicTexture.getInternalTexture().uniqueId : 0;\n                    const roughnessId = roughnessTexture && roughnessTexture.getInternalTexture() ? roughnessTexture.getInternalTexture().uniqueId : 0;\n                    const mergedId = Number(`${metallicId}${roughnessId}`);\n                    const glTFTexture = this._textureMap.get(mergedId);\n                    if (glTFTexture) {\n                        glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFTexture;\n                    }\n                    else {\n                        promises.push((0,_babylonjs_core_Materials_Textures_textureMerger_js__WEBPACK_IMPORTED_MODULE_12__.MergeTexturesAsync)(\"MetalRoughTexture\", (0,_babylonjs_core_Materials_Textures_textureMerger_js__WEBPACK_IMPORTED_MODULE_12__.CreateRGBAConfiguration)(babylonPBRMaterial.ambientOcclusionTexture ? (0,_babylonjs_core_Materials_Textures_textureMerger_js__WEBPACK_IMPORTED_MODULE_12__.CreateTextureInput)(babylonPBRMaterial.ambientOcclusionTexture, 0) : (0,_babylonjs_core_Materials_Textures_textureMerger_js__WEBPACK_IMPORTED_MODULE_12__.CreateConstantInput)(1.0), roughnessTexture ? (0,_babylonjs_core_Materials_Textures_textureMerger_js__WEBPACK_IMPORTED_MODULE_12__.CreateTextureInput)(roughnessTexture, 0) : (0,_babylonjs_core_Materials_Textures_textureMerger_js__WEBPACK_IMPORTED_MODULE_12__.CreateConstantInput)(1.0), metallicTexture ? (0,_babylonjs_core_Materials_Textures_textureMerger_js__WEBPACK_IMPORTED_MODULE_12__.CreateTextureInput)(metallicTexture, 0) : (0,_babylonjs_core_Materials_Textures_textureMerger_js__WEBPACK_IMPORTED_MODULE_12__.CreateConstantInput)(1.0)), babylonPBRMaterial.getScene()).then(async (mergedTexture) => {\n                            const glTFTexture = await this.exportTextureAsync(mergedTexture, mergedId);\n                            if (glTFTexture) {\n                                glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFTexture;\n                            }\n                        }));\n                    }\n                }\n            }\n            else {\n                if (albedoTexture) {\n                    promises.push(this.exportTextureAsync(albedoTexture).then((glTFTexture) => {\n                        if (glTFTexture) {\n                            glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\n                        }\n                    }));\n                }\n                if (metallicTexture) {\n                    promises.push(this.exportTextureAsync(metallicTexture).then((glTFTexture) => {\n                        if (glTFTexture) {\n                            glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFTexture;\n                        }\n                    }));\n                }\n            }\n        }\n        if (promises.length > 0) {\n            this._exporter._materialNeedsUVsSet.add(babylonPBRMaterial);\n            await Promise.all(promises);\n        }\n        return metallicRoughness;\n    }\n    _getTextureSampler(texture) {\n        const sampler = {};\n        if (!texture || !(texture instanceof _babylonjs_core_Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_4__.Texture)) {\n            return sampler;\n        }\n        const wrapS = this._getGLTFTextureWrapMode(texture.wrapU);\n        if (wrapS !== 10497 /* TextureWrapMode.REPEAT */) {\n            sampler.wrapS = wrapS;\n        }\n        const wrapT = this._getGLTFTextureWrapMode(texture.wrapV);\n        if (wrapT !== 10497 /* TextureWrapMode.REPEAT */) {\n            sampler.wrapT = wrapT;\n        }\n        switch (texture.samplingMode) {\n            case _babylonjs_core_Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_4__.Texture.LINEAR_LINEAR: {\n                sampler.magFilter = 9729 /* TextureMagFilter.LINEAR */;\n                sampler.minFilter = 9729 /* TextureMinFilter.LINEAR */;\n                break;\n            }\n            case _babylonjs_core_Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_4__.Texture.LINEAR_NEAREST: {\n                sampler.magFilter = 9729 /* TextureMagFilter.LINEAR */;\n                sampler.minFilter = 9728 /* TextureMinFilter.NEAREST */;\n                break;\n            }\n            case _babylonjs_core_Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_4__.Texture.NEAREST_LINEAR: {\n                sampler.magFilter = 9728 /* TextureMagFilter.NEAREST */;\n                sampler.minFilter = 9729 /* TextureMinFilter.LINEAR */;\n                break;\n            }\n            case _babylonjs_core_Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_4__.Texture.NEAREST_LINEAR_MIPLINEAR: {\n                sampler.magFilter = 9728 /* TextureMagFilter.NEAREST */;\n                sampler.minFilter = 9987 /* TextureMinFilter.LINEAR_MIPMAP_LINEAR */;\n                break;\n            }\n            case _babylonjs_core_Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_4__.Texture.NEAREST_NEAREST: {\n                sampler.magFilter = 9728 /* TextureMagFilter.NEAREST */;\n                sampler.minFilter = 9728 /* TextureMinFilter.NEAREST */;\n                break;\n            }\n            case _babylonjs_core_Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_4__.Texture.NEAREST_LINEAR_MIPNEAREST: {\n                sampler.magFilter = 9728 /* TextureMagFilter.NEAREST */;\n                sampler.minFilter = 9985 /* TextureMinFilter.LINEAR_MIPMAP_NEAREST */;\n                break;\n            }\n            case _babylonjs_core_Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_4__.Texture.LINEAR_NEAREST_MIPNEAREST: {\n                sampler.magFilter = 9729 /* TextureMagFilter.LINEAR */;\n                sampler.minFilter = 9984 /* TextureMinFilter.NEAREST_MIPMAP_NEAREST */;\n                break;\n            }\n            case _babylonjs_core_Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_4__.Texture.LINEAR_NEAREST_MIPLINEAR: {\n                sampler.magFilter = 9729 /* TextureMagFilter.LINEAR */;\n                sampler.minFilter = 9986 /* TextureMinFilter.NEAREST_MIPMAP_LINEAR */;\n                break;\n            }\n            case _babylonjs_core_Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_4__.Texture.NEAREST_NEAREST_MIPLINEAR: {\n                sampler.magFilter = 9728 /* TextureMagFilter.NEAREST */;\n                sampler.minFilter = 9986 /* TextureMinFilter.NEAREST_MIPMAP_LINEAR */;\n                break;\n            }\n            case _babylonjs_core_Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_4__.Texture.LINEAR_LINEAR_MIPLINEAR: {\n                sampler.magFilter = 9729 /* TextureMagFilter.LINEAR */;\n                sampler.minFilter = 9987 /* TextureMinFilter.LINEAR_MIPMAP_LINEAR */;\n                break;\n            }\n            case _babylonjs_core_Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_4__.Texture.LINEAR_LINEAR_MIPNEAREST: {\n                sampler.magFilter = 9729 /* TextureMagFilter.LINEAR */;\n                sampler.minFilter = 9985 /* TextureMinFilter.LINEAR_MIPMAP_NEAREST */;\n                break;\n            }\n            case _babylonjs_core_Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_4__.Texture.NEAREST_NEAREST_MIPNEAREST: {\n                sampler.magFilter = 9728 /* TextureMagFilter.NEAREST */;\n                sampler.minFilter = 9984 /* TextureMinFilter.NEAREST_MIPMAP_NEAREST */;\n                break;\n            }\n        }\n        return sampler;\n    }\n    _getGLTFTextureWrapMode(wrapMode) {\n        switch (wrapMode) {\n            case _babylonjs_core_Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_4__.Texture.WRAP_ADDRESSMODE: {\n                return 10497 /* TextureWrapMode.REPEAT */;\n            }\n            case _babylonjs_core_Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_4__.Texture.CLAMP_ADDRESSMODE: {\n                return 33071 /* TextureWrapMode.CLAMP_TO_EDGE */;\n            }\n            case _babylonjs_core_Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_4__.Texture.MIRROR_ADDRESSMODE: {\n                return 33648 /* TextureWrapMode.MIRRORED_REPEAT */;\n            }\n            default: {\n                _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_2__.Tools.Error(`Unsupported Texture Wrap Mode ${wrapMode}!`);\n                return 10497 /* TextureWrapMode.REPEAT */;\n            }\n        }\n    }\n    /**\n     * Convert a PBRMaterial (Specular/Glossiness) to Metallic Roughness factors\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\n     * @param pbrMetallicRoughness glTF PBR Metallic Roughness interface\n     * @param hasUVs specifies if texture coordinates are present on the submesh to determine if textures should be applied\n     * @returns glTF PBR Metallic Roughness factors\n     */\n    async _convertSpecGlossFactorsToMetallicRoughnessAsync(babylonPBRMaterial, pbrMetallicRoughness, hasUVs) {\n        const specGloss = {\n            diffuseColor: babylonPBRMaterial._albedoColor,\n            specularColor: babylonPBRMaterial._reflectivityColor,\n            glossiness: babylonPBRMaterial._microSurface,\n        };\n        const albedoTexture = babylonPBRMaterial._albedoTexture;\n        const reflectivityTexture = babylonPBRMaterial._reflectivityTexture;\n        const useMicrosurfaceFromReflectivityMapAlpha = babylonPBRMaterial._useMicroSurfaceFromReflectivityMapAlpha;\n        if (reflectivityTexture && !useMicrosurfaceFromReflectivityMapAlpha) {\n            return await Promise.reject(\"_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported\");\n        }\n        if ((albedoTexture || reflectivityTexture) && hasUVs) {\n            this._exporter._materialNeedsUVsSet.add(babylonPBRMaterial);\n            const samplerIndex = this._exportTextureSampler(albedoTexture || reflectivityTexture);\n            const metallicRoughnessFactors = await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(albedoTexture, reflectivityTexture, specGloss);\n            const textures = this._exporter._textures;\n            if (metallicRoughnessFactors.baseColorTextureData) {\n                const imageIndex = await this._exportImageAsync(`baseColor${textures.length}`, metallicRoughnessFactors.baseColorTextureData);\n                pbrMetallicRoughness.baseColorTexture = this._exportTextureInfo(imageIndex, samplerIndex, albedoTexture?.coordinatesIndex);\n            }\n            if (metallicRoughnessFactors.metallicRoughnessTextureData) {\n                const imageIndex = await this._exportImageAsync(`metallicRoughness${textures.length}`, metallicRoughnessFactors.metallicRoughnessTextureData);\n                pbrMetallicRoughness.metallicRoughnessTexture = this._exportTextureInfo(imageIndex, samplerIndex, reflectivityTexture?.coordinatesIndex);\n            }\n            return metallicRoughnessFactors;\n        }\n        else {\n            return this._convertSpecularGlossinessToMetallicRoughness(specGloss);\n        }\n    }\n    async exportPBRMaterialAsync(babylonPBRMaterial, hasUVs) {\n        const glTFPbrMetallicRoughness = {};\n        const glTFMaterial = {\n            name: babylonPBRMaterial.name,\n        };\n        const useMetallicRoughness = babylonPBRMaterial.isMetallicWorkflow();\n        if (useMetallicRoughness) {\n            const albedoColor = babylonPBRMaterial._albedoColor;\n            const alpha = babylonPBRMaterial.alpha;\n            if (albedoColor) {\n                glTFPbrMetallicRoughness.baseColorFactor = [albedoColor.r, albedoColor.g, albedoColor.b, alpha];\n            }\n        }\n        const metallicRoughness = useMetallicRoughness\n            ? await this._convertMetalRoughFactorsToMetallicRoughnessAsync(babylonPBRMaterial._albedoColor, babylonPBRMaterial._metallic, babylonPBRMaterial._roughness, babylonPBRMaterial._albedoTexture, babylonPBRMaterial._metallicTexture, babylonPBRMaterial._metallicTexture, babylonPBRMaterial, glTFPbrMetallicRoughness, hasUVs)\n            : await this._convertSpecGlossFactorsToMetallicRoughnessAsync(babylonPBRMaterial, glTFPbrMetallicRoughness, hasUVs);\n        await this._setMetallicRoughnessPbrMaterialAsync(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, hasUVs);\n        await this._finishMaterialAsync(glTFMaterial, babylonPBRMaterial);\n        const materials = this._exporter._materials;\n        materials.push(glTFMaterial);\n        return materials.length - 1;\n    }\n    async _setMetallicRoughnessPbrMaterialAsync(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, hasUVs) {\n        SetAlphaMode(glTFMaterial, babylonPBRMaterial);\n        if (!metallicRoughness.baseColor.equalsWithEpsilon(White, Epsilon) || !_babylonjs_core_Maths_math_scalar_js__WEBPACK_IMPORTED_MODULE_1__.Scalar.WithinEpsilon(babylonPBRMaterial.alpha, 1, Epsilon)) {\n            glTFPbrMetallicRoughness.baseColorFactor = [metallicRoughness.baseColor.r, metallicRoughness.baseColor.g, metallicRoughness.baseColor.b, babylonPBRMaterial.alpha];\n        }\n        if (metallicRoughness.metallic != null && metallicRoughness.metallic !== 1) {\n            glTFPbrMetallicRoughness.metallicFactor = metallicRoughness.metallic;\n        }\n        if (metallicRoughness.roughness != null && metallicRoughness.roughness !== 1) {\n            glTFPbrMetallicRoughness.roughnessFactor = metallicRoughness.roughness;\n        }\n        if (babylonPBRMaterial.backFaceCulling != null && !babylonPBRMaterial.backFaceCulling) {\n            if (!babylonPBRMaterial._twoSidedLighting) {\n                _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_2__.Tools.Warn(babylonPBRMaterial.name + \": Back-face culling disabled and two-sided lighting disabled is not supported in glTF.\");\n            }\n            glTFMaterial.doubleSided = true;\n        }\n        if (hasUVs) {\n            const promises = [];\n            const bumpTexture = babylonPBRMaterial instanceof _babylonjs_core_Materials_PBR_pbrBaseMaterial_js__WEBPACK_IMPORTED_MODULE_8__.PBRBaseMaterial ? babylonPBRMaterial._bumpTexture : babylonPBRMaterial.geometryNormalTexture;\n            if (bumpTexture) {\n                promises.push(this.exportTextureAsync(bumpTexture).then((glTFTexture) => {\n                    if (glTFTexture) {\n                        glTFMaterial.normalTexture = glTFTexture;\n                        if (bumpTexture.level !== 1) {\n                            glTFMaterial.normalTexture.scale = bumpTexture.level;\n                        }\n                    }\n                }));\n            }\n            const ambientTexture = babylonPBRMaterial instanceof _babylonjs_core_Materials_PBR_pbrBaseMaterial_js__WEBPACK_IMPORTED_MODULE_8__.PBRBaseMaterial ? babylonPBRMaterial._ambientTexture : babylonPBRMaterial.ambientOcclusionTexture;\n            if (ambientTexture) {\n                promises.push(new Promise(async (resolve) => {\n                    if (babylonPBRMaterial instanceof _babylonjs_core_Materials_PBR_openpbrMaterial_js__WEBPACK_IMPORTED_MODULE_11__.OpenPBRMaterial && glTFPbrMetallicRoughness.metallicRoughnessTexture) {\n                        // The metallicRoughnessTexture already contains the ambient occlusion data in its red channel, we don't need to export it again\n                        // However, we still need to set the texture info on the material.\n                        const samplerIndex = this._exportTextureSampler(ambientTexture);\n                        const imageIndex = this._exporter._textures[glTFPbrMetallicRoughness.metallicRoughnessTexture.index].source;\n                        const textureInfo = this._exportTextureInfo(imageIndex, samplerIndex, ambientTexture.coordinatesIndex);\n                        this._textureMap.set(ambientTexture.uniqueId, textureInfo);\n                        this._exporter._extensionsPostExportTextures(\"exporter\", textureInfo, ambientTexture);\n                        return resolve(textureInfo);\n                    }\n                    else {\n                        return resolve(await this.exportTextureAsync(ambientTexture));\n                    }\n                }).then(async (glTFTexture) => {\n                    if (glTFTexture) {\n                        const occlusionTexture = {\n                            index: glTFTexture.index,\n                            texCoord: glTFTexture.texCoord,\n                            extensions: glTFTexture.extensions,\n                        };\n                        glTFMaterial.occlusionTexture = occlusionTexture;\n                        if (babylonPBRMaterial instanceof _babylonjs_core_Materials_PBR_pbrBaseMaterial_js__WEBPACK_IMPORTED_MODULE_8__.PBRBaseMaterial) {\n                            occlusionTexture.strength = babylonPBRMaterial._ambientTextureStrength;\n                        }\n                        else {\n                            occlusionTexture.strength = babylonPBRMaterial.ambientOcclusionTexture.level;\n                        }\n                    }\n                }));\n            }\n            const emissiveTexture = babylonPBRMaterial instanceof _babylonjs_core_Materials_PBR_pbrBaseMaterial_js__WEBPACK_IMPORTED_MODULE_8__.PBRBaseMaterial ? babylonPBRMaterial._emissiveTexture : babylonPBRMaterial.emissionColorTexture;\n            if (emissiveTexture) {\n                promises.push(this.exportTextureAsync(emissiveTexture).then((glTFTexture) => {\n                    if (glTFTexture) {\n                        glTFMaterial.emissiveTexture = glTFTexture;\n                    }\n                }));\n            }\n            if (promises.length > 0) {\n                this._exporter._materialNeedsUVsSet.add(babylonPBRMaterial);\n                await Promise.all(promises);\n            }\n        }\n        const emissiveColor = babylonPBRMaterial instanceof _babylonjs_core_Materials_PBR_pbrBaseMaterial_js__WEBPACK_IMPORTED_MODULE_8__.PBRBaseMaterial ? babylonPBRMaterial._emissiveColor : babylonPBRMaterial.emissionColor;\n        if (!emissiveColor.equalsWithEpsilon(Black, Epsilon)) {\n            glTFMaterial.emissiveFactor = emissiveColor.asArray();\n        }\n        glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;\n    }\n    async exportOpenPBRMaterialAsync(babylonOpenPBRMaterial, hasUVs) {\n        const glTFPbrMetallicRoughness = {};\n        const glTFMaterial = {\n            name: babylonOpenPBRMaterial.name,\n        };\n        const albedoColor = babylonOpenPBRMaterial.baseColor;\n        const alpha = babylonOpenPBRMaterial.geometryOpacity;\n        if (albedoColor) {\n            glTFPbrMetallicRoughness.baseColorFactor = [albedoColor.r, albedoColor.g, albedoColor.b, alpha];\n        }\n        const metallicRoughness = await this._convertMetalRoughFactorsToMetallicRoughnessAsync(babylonOpenPBRMaterial.baseColor, babylonOpenPBRMaterial.baseMetalness, babylonOpenPBRMaterial.specularRoughness, babylonOpenPBRMaterial.baseColorTexture, babylonOpenPBRMaterial.baseMetalnessTexture, babylonOpenPBRMaterial.specularRoughnessTexture, babylonOpenPBRMaterial, glTFPbrMetallicRoughness, hasUVs);\n        await this._setMetallicRoughnessPbrMaterialAsync(metallicRoughness, babylonOpenPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, hasUVs);\n        await this._finishMaterialAsync(glTFMaterial, babylonOpenPBRMaterial);\n        const materials = this._exporter._materials;\n        materials.push(glTFMaterial);\n        return materials.length - 1;\n    }\n    async exportTextureAsync(babylonTexture, overrideId = null) {\n        let textureInfo = this._textureMap.get(overrideId ?? babylonTexture.uniqueId);\n        if (textureInfo) {\n            return textureInfo;\n        }\n        const samplerIndex = this._exportTextureSampler(babylonTexture);\n        const imageIndex = await this._exportTextureImageAsync(babylonTexture);\n        textureInfo = this._exportTextureInfo(imageIndex, samplerIndex, babylonTexture.coordinatesIndex);\n        this._textureMap.set(overrideId ?? babylonTexture.uniqueId, textureInfo);\n        this._exporter._extensionsPostExportTextures(\"exporter\", textureInfo, babylonTexture);\n        return textureInfo;\n    }\n    async _exportTextureImageAsync(babylonTexture) {\n        const requestedMimeType = babylonTexture.mimeType ?? \"none\";\n        // TODO: Add an official way for users to export using a different mime type\n        // than the one they loaded with (which is denoted by Texture.mimeType)\n        const internalTextureToImage = this._internalTextureToImage;\n        const internalTextureUniqueId = babylonTexture.getInternalTexture().uniqueId;\n        internalTextureToImage[internalTextureUniqueId] = internalTextureToImage[internalTextureUniqueId] || {};\n        let imageIndexPromise = internalTextureToImage[internalTextureUniqueId][requestedMimeType];\n        if (imageIndexPromise === undefined) {\n            imageIndexPromise = (async () => {\n                // Try to get the image from memory first, if applicable\n                const cache = await GetCachedImageAsync(babylonTexture);\n                if (cache && (requestedMimeType === \"none\" || cache.type === requestedMimeType)) {\n                    return await this._exportImageAsync(babylonTexture.name, cache);\n                }\n                // Preserve texture mime type if defined\n                let mimeType = \"image/png\" /* ImageMimeType.PNG */;\n                if (requestedMimeType !== \"none\") {\n                    if (IsSupportedMimeType(requestedMimeType)) {\n                        mimeType = requestedMimeType;\n                    }\n                    else {\n                        mimeType = \"image/png\" /* ImageMimeType.PNG */;\n                        _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_2__.Tools.Warn(`Unsupported media type: ${requestedMimeType}. Exporting texture as PNG.`);\n                    }\n                }\n                const size = babylonTexture.getSize();\n                const pixels = await (0,_babylonjs_core_Misc_textureTools_js__WEBPACK_IMPORTED_MODULE_3__.GetTextureDataAsync)(babylonTexture);\n                const imageData = await (0,_babylonjs_core_Misc_dumpTools_js__WEBPACK_IMPORTED_MODULE_7__.EncodeImageAsync)(pixels, size.width, size.height, mimeType);\n                return await this._exportImageAsync(babylonTexture.name, imageData);\n            })();\n            internalTextureToImage[internalTextureUniqueId][requestedMimeType] = imageIndexPromise;\n        }\n        return await imageIndexPromise;\n    }\n    async _exportImageAsync(name, imageData) {\n        const images = this._exporter._images;\n        let image;\n        if (this._exporter._shouldUseGlb) {\n            image = {\n                name: name,\n                mimeType: imageData.type,\n                bufferView: undefined, // Will be updated later by BufferManager\n            };\n            const data = await imageData.arrayBuffer();\n            const bufferView = this._exporter._bufferManager.createBufferView(new Uint8Array(data));\n            this._exporter._bufferManager.setBufferView(image, bufferView);\n        }\n        else {\n            // Build a unique URI\n            const baseName = name.replace(/\\.\\/|\\/|\\.\\\\|\\\\/g, \"_\");\n            const extension = GetFileExtensionFromMimeType(imageData.type);\n            let fileName = baseName + extension;\n            if (images.some((image) => image.uri === fileName)) {\n                fileName = `${baseName}_${_babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_2__.Tools.RandomId()}${extension}`;\n            }\n            image = {\n                name: name,\n                uri: fileName,\n            };\n            this._exporter._imageData[fileName] = imageData; // Save image data to be written to file later\n        }\n        images.push(image);\n        return images.length - 1;\n    }\n    _exportTextureInfo(imageIndex, samplerIndex, coordinatesIndex) {\n        const textures = this._exporter._textures;\n        let textureIndex = textures.findIndex((t) => t.sampler == samplerIndex && t.source === imageIndex);\n        if (textureIndex === -1) {\n            textureIndex = textures.length;\n            textures.push({\n                source: imageIndex,\n                sampler: samplerIndex,\n            });\n        }\n        const textureInfo = { index: textureIndex };\n        if (coordinatesIndex) {\n            textureInfo.texCoord = coordinatesIndex;\n        }\n        return textureInfo;\n    }\n    _exportTextureSampler(texture) {\n        const sampler = this._getTextureSampler(texture);\n        // if a pre-existing sampler with identical parameters exists, then reuse the previous sampler\n        const samplers = this._exporter._samplers;\n        const samplerIndex = samplers.findIndex((s) => s.minFilter === sampler.minFilter && s.magFilter === sampler.magFilter && s.wrapS === sampler.wrapS && s.wrapT === sampler.wrapT);\n        if (samplerIndex !== -1) {\n            return samplerIndex;\n        }\n        samplers.push(sampler);\n        return samplers.length - 1;\n    }\n}\n//# sourceMappingURL=glTFMaterialExporter.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/serializers/glTF/2.0/glTFMaterialExporter.js?\n}");

/***/ },

/***/ "./node_modules/@babylonjs/serializers/glTF/2.0/glTFMorphTargetsUtilities.js"
/*!***********************************************************************************!*\
  !*** ./node_modules/@babylonjs/serializers/glTF/2.0/glTFMorphTargetsUtilities.js ***!
  \***********************************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BuildMorphTargetBuffers: () => (/* binding */ BuildMorphTargetBuffers)\n/* harmony export */ });\n/* harmony import */ var _glTFUtilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./glTFUtilities.js */ \"./node_modules/@babylonjs/serializers/glTF/2.0/glTFUtilities.js\");\n/* harmony import */ var _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babylonjs/core/Buffers/buffer.js */ \"./node_modules/@babylonjs/core/Buffers/buffer.js\");\n/* harmony import */ var _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babylonjs/core/Maths/math.vector.js */ \"./node_modules/@babylonjs/core/Maths/math.vector.js\");\n/* harmony import */ var _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babylonjs/core/Misc/tools.js */ \"./node_modules/@babylonjs/core/Misc/tools.js\");\n\n\n\n\nfunction BuildMorphTargetBuffers(morphTarget, mesh, bufferManager, bufferViews, accessors, convertToRightHanded) {\n    const result = {\n        attributes: {},\n        influence: morphTarget.influence,\n        name: morphTarget.name,\n    };\n    const geometry = mesh.geometry;\n    if (!geometry) {\n        _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_3__.Tools.Warn(\"Attempted to export morph target data from a mesh without geometry. This should not happen.\");\n        return result;\n    }\n    const flipX = convertToRightHanded ? -1 : 1;\n    const floatSize = 4;\n    const difference = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_2__.Vector3.Zero();\n    let vertexStart = 0;\n    let vertexCount = 0;\n    if (morphTarget.hasPositions) {\n        const morphPositions = morphTarget.getPositions();\n        const originalPositions = geometry.getVerticesData(_babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.PositionKind); // Bypasses any instance data of mesh\n        if (originalPositions) {\n            const positionData = new Float32Array(originalPositions.length);\n            const min = [Infinity, Infinity, Infinity];\n            const max = [-Infinity, -Infinity, -Infinity];\n            vertexCount = originalPositions.length / 3;\n            vertexStart = 0;\n            for (let i = vertexStart; i < vertexCount; ++i) {\n                const originalPosition = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_2__.Vector3.FromArray(originalPositions, i * 3);\n                const morphPosition = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_2__.Vector3.FromArray(morphPositions, i * 3);\n                morphPosition.subtractToRef(originalPosition, difference);\n                difference.x *= flipX;\n                min[0] = Math.min(min[0], difference.x);\n                max[0] = Math.max(max[0], difference.x);\n                min[1] = Math.min(min[1], difference.y);\n                max[1] = Math.max(max[1], difference.y);\n                min[2] = Math.min(min[2], difference.z);\n                max[2] = Math.max(max[2], difference.z);\n                positionData[i * 3] = difference.x;\n                positionData[i * 3 + 1] = difference.y;\n                positionData[i * 3 + 2] = difference.z;\n            }\n            const bufferView = bufferManager.createBufferView(positionData, floatSize * 3);\n            const accessor = bufferManager.createAccessor(bufferView, \"VEC3\" /* AccessorType.VEC3 */, 5126 /* AccessorComponentType.FLOAT */, morphPositions.length / 3, 0, { min, max });\n            accessors.push(accessor);\n            result.attributes[\"POSITION\"] = accessors.length - 1;\n        }\n        else {\n            _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_3__.Tools.Warn(`Morph target positions for mesh ${mesh.name} were not exported. Mesh does not have position vertex data`);\n        }\n    }\n    if (morphTarget.hasNormals) {\n        const morphNormals = morphTarget.getNormals();\n        const originalNormals = geometry.getVerticesData(_babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.NormalKind);\n        if (originalNormals) {\n            const normalData = new Float32Array(originalNormals.length);\n            vertexCount = originalNormals.length / 3;\n            vertexStart = 0;\n            for (let i = vertexStart; i < vertexCount; ++i) {\n                const originalNormal = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_2__.Vector3.FromArray(originalNormals, i * 3).normalize();\n                const morphNormal = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_2__.Vector3.FromArray(morphNormals, i * 3).normalize();\n                morphNormal.subtractToRef(originalNormal, difference);\n                normalData[i * 3] = difference.x * flipX;\n                normalData[i * 3 + 1] = difference.y;\n                normalData[i * 3 + 2] = difference.z;\n            }\n            const bufferView = bufferManager.createBufferView(normalData, floatSize * 3);\n            const accessor = bufferManager.createAccessor(bufferView, \"VEC3\" /* AccessorType.VEC3 */, 5126 /* AccessorComponentType.FLOAT */, morphNormals.length / 3, 0);\n            accessors.push(accessor);\n            result.attributes[\"NORMAL\"] = accessors.length - 1;\n        }\n        else {\n            _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_3__.Tools.Warn(`Morph target normals for mesh ${mesh.name} were not exported. Mesh does not have normals vertex data`);\n        }\n    }\n    if (morphTarget.hasTangents) {\n        const morphTangents = morphTarget.getTangents();\n        const originalTangents = geometry.getVerticesData(_babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.TangentKind);\n        if (originalTangents) {\n            vertexCount = originalTangents.length / 4;\n            const tangentData = new Float32Array(vertexCount * 3);\n            vertexStart = 0;\n            for (let i = vertexStart; i < vertexCount; ++i) {\n                // Only read the x, y, z components and ignore w\n                const originalTangent = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_2__.Vector3.FromArray(originalTangents, i * 4);\n                (0,_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_0__.NormalizeTangent)(originalTangent);\n                // Morph target tangents omit the w component so it won't be present in the data\n                const morphTangent = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_2__.Vector3.FromArray(morphTangents, i * 3);\n                (0,_glTFUtilities_js__WEBPACK_IMPORTED_MODULE_0__.NormalizeTangent)(morphTangent);\n                morphTangent.subtractToRef(originalTangent, difference);\n                tangentData[i * 3] = difference.x * flipX;\n                tangentData[i * 3 + 1] = difference.y;\n                tangentData[i * 3 + 2] = difference.z;\n            }\n            const bufferView = bufferManager.createBufferView(tangentData, floatSize * 3);\n            const accessor = bufferManager.createAccessor(bufferView, \"VEC3\" /* AccessorType.VEC3 */, 5126 /* AccessorComponentType.FLOAT */, vertexCount, 0);\n            accessors.push(accessor);\n            result.attributes[\"TANGENT\"] = accessors.length - 1;\n        }\n        else {\n            _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_3__.Tools.Warn(`Morph target tangents for mesh ${mesh.name} were not exported. Mesh does not have tangents vertex data`);\n        }\n    }\n    if (morphTarget.hasColors) {\n        const morphColors = morphTarget.getColors();\n        const originalColors = geometry.getVerticesData(_babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.ColorKind);\n        const buffer = geometry.getVertexBuffer(_babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.ColorKind);\n        if (originalColors && buffer) {\n            const componentSize = buffer.getSize();\n            vertexCount = originalColors.length / componentSize;\n            const colorData = new Float32Array(vertexCount * componentSize);\n            vertexStart = 0;\n            for (let i = vertexStart; i < vertexCount; ++i) {\n                if (componentSize === 3) {\n                    const originalColor = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_2__.Vector3.FromArray(originalColors, i * componentSize);\n                    const morphColor = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_2__.Vector3.FromArray(morphColors, i * componentSize);\n                    morphColor.subtractToRef(originalColor, difference);\n                    colorData[i * 3] = difference.x;\n                    colorData[i * 3 + 1] = difference.y;\n                    colorData[i * 3 + 2] = difference.z;\n                }\n                else if (componentSize === 4) {\n                    const difference4 = new _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_2__.Vector4();\n                    const originalColor = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_2__.Vector4.FromArray(originalColors, i * componentSize);\n                    const morphColor = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_2__.Vector4.FromArray(morphColors, i * componentSize);\n                    morphColor.subtractToRef(originalColor, difference4);\n                    colorData[i * 4] = difference4.x;\n                    colorData[i * 4 + 1] = difference4.y;\n                    colorData[i * 4 + 2] = difference4.z;\n                    colorData[i * 4 + 3] = difference4.w;\n                }\n                else {\n                    _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_3__.Tools.Warn(`Unsupported number of components for color attribute: ${componentSize}`);\n                }\n            }\n            const bufferView = bufferManager.createBufferView(colorData, floatSize * componentSize);\n            const accessor = bufferManager.createAccessor(bufferView, componentSize === 3 ? \"VEC3\" /* AccessorType.VEC3 */ : \"VEC4\" /* AccessorType.VEC4 */, 5126 /* AccessorComponentType.FLOAT */, vertexCount, 0);\n            accessors.push(accessor);\n            result.attributes[\"COLOR_0\"] = accessors.length - 1;\n        }\n        else {\n            _babylonjs_core_Misc_tools_js__WEBPACK_IMPORTED_MODULE_3__.Tools.Warn(`Morph target colors for mesh ${mesh.name} were not exported. Mesh does not have colors vertex data`);\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=glTFMorphTargetsUtilities.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/serializers/glTF/2.0/glTFMorphTargetsUtilities.js?\n}");

/***/ },

/***/ "./node_modules/@babylonjs/serializers/glTF/2.0/glTFSerializer.js"
/*!************************************************************************!*\
  !*** ./node_modules/@babylonjs/serializers/glTF/2.0/glTFSerializer.js ***!
  \************************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLTF2Export: () => (/* binding */ GLTF2Export)\n/* harmony export */ });\n/* harmony import */ var _glTFExporter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./glTFExporter.js */ \"./node_modules/@babylonjs/serializers/glTF/2.0/glTFExporter.js\");\n\n/**\n * Class for generating glTF data from a Babylon scene.\n */\nclass GLTF2Export {\n    /**\n     * Exports the scene to .gltf file format\n     * @param scene Babylon scene\n     * @param fileName Name to use for the .gltf file\n     * @param options Exporter options\n     * @returns Returns the exported data\n     */\n    static async GLTFAsync(scene, fileName, options) {\n        if (!options || !options.exportWithoutWaitingForScene) {\n            await scene.whenReadyAsync();\n        }\n        const exporter = new _glTFExporter_js__WEBPACK_IMPORTED_MODULE_0__.GLTFExporter(scene, options);\n        const data = await exporter.generateGLTFAsync(fileName.replace(/\\.[^/.]+$/, \"\"));\n        exporter.dispose();\n        return data;\n    }\n    /**\n     * Exports the scene to .glb file format\n     * @param scene Babylon scene\n     * @param fileName Name to use for the .glb file\n     * @param options Exporter options\n     * @returns Returns the exported data\n     */\n    static async GLBAsync(scene, fileName, options) {\n        if (!options || !options.exportWithoutWaitingForScene) {\n            await scene.whenReadyAsync();\n        }\n        const exporter = new _glTFExporter_js__WEBPACK_IMPORTED_MODULE_0__.GLTFExporter(scene, options);\n        const data = await exporter.generateGLBAsync(fileName.replace(/\\.[^/.]+$/, \"\"));\n        exporter.dispose();\n        return data;\n    }\n}\n//# sourceMappingURL=glTFSerializer.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/serializers/glTF/2.0/glTFSerializer.js?\n}");

/***/ },

/***/ "./node_modules/@babylonjs/serializers/glTF/2.0/glTFUtilities.js"
/*!***********************************************************************!*\
  !*** ./node_modules/@babylonjs/serializers/glTF/2.0/glTFUtilities.js ***!
  \***********************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CollapseChildIntoParent: () => (/* binding */ CollapseChildIntoParent),\n/* harmony export */   ConvertToRightHandedPosition: () => (/* binding */ ConvertToRightHandedPosition),\n/* harmony export */   ConvertToRightHandedRotation: () => (/* binding */ ConvertToRightHandedRotation),\n/* harmony export */   ConvertToRightHandedTransformMatrix: () => (/* binding */ ConvertToRightHandedTransformMatrix),\n/* harmony export */   DataArrayToUint8Array: () => (/* binding */ DataArrayToUint8Array),\n/* harmony export */   DefaultRotation: () => (/* binding */ DefaultRotation),\n/* harmony export */   DefaultScale: () => (/* binding */ DefaultScale),\n/* harmony export */   DefaultTranslation: () => (/* binding */ DefaultTranslation),\n/* harmony export */   FloatsNeed16BitInteger: () => (/* binding */ FloatsNeed16BitInteger),\n/* harmony export */   GetAccessorElementCount: () => (/* binding */ GetAccessorElementCount),\n/* harmony export */   GetAccessorType: () => (/* binding */ GetAccessorType),\n/* harmony export */   GetAttributeType: () => (/* binding */ GetAttributeType),\n/* harmony export */   GetMinMax: () => (/* binding */ GetMinMax),\n/* harmony export */   GetPrimitiveMode: () => (/* binding */ GetPrimitiveMode),\n/* harmony export */   GetVertexBufferInfo: () => (/* binding */ GetVertexBufferInfo),\n/* harmony export */   IndicesArrayToTypedSubarray: () => (/* binding */ IndicesArrayToTypedSubarray),\n/* harmony export */   IsChildCollapsible: () => (/* binding */ IsChildCollapsible),\n/* harmony export */   IsStandardVertexAttribute: () => (/* binding */ IsStandardVertexAttribute),\n/* harmony export */   IsTriangleFillMode: () => (/* binding */ IsTriangleFillMode),\n/* harmony export */   NormalizeTangent: () => (/* binding */ NormalizeTangent),\n/* harmony export */   OmitDefaultValues: () => (/* binding */ OmitDefaultValues),\n/* harmony export */   Rotate180Y: () => (/* binding */ Rotate180Y)\n/* harmony export */ });\n/* harmony import */ var _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babylonjs/core/Maths/math.vector.js */ \"./node_modules/@babylonjs/core/Maths/math.vector.js\");\n/* harmony import */ var _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babylonjs/core/Buffers/buffer.js */ \"./node_modules/@babylonjs/core/Buffers/buffer.js\");\n/* harmony import */ var _babylonjs_core_Materials_material_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babylonjs/core/Materials/material.js */ \"./node_modules/@babylonjs/core/Materials/material.js\");\n/* harmony import */ var _babylonjs_core_Meshes_transformNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babylonjs/core/Meshes/transformNode.js */ \"./node_modules/@babylonjs/core/Meshes/transformNode.js\");\n/* harmony import */ var _babylonjs_core_Buffers_bufferUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babylonjs/core/Buffers/bufferUtils.js */ \"./node_modules/@babylonjs/core/Buffers/bufferUtils.js\");\n/* harmony import */ var _babylonjs_core_Misc_logger_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babylonjs/core/Misc/logger.js */ \"./node_modules/@babylonjs/core/Misc/logger.js\");\n/* harmony import */ var _babylonjs_core_Cameras_targetCamera_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babylonjs/core/Cameras/targetCamera.js */ \"./node_modules/@babylonjs/core/Cameras/targetCamera.js\");\n/* harmony import */ var _babylonjs_core_Maths_math_constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babylonjs/core/Maths/math.constants.js */ \"./node_modules/@babylonjs/core/Maths/math.constants.js\");\n/* harmony import */ var _exportUtils_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../exportUtils.js */ \"./node_modules/@babylonjs/serializers/exportUtils.js\");\n\n\n\n\n\n\n\n\n\n// Default values for comparison.\nconst DefaultTranslation = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZeroReadOnly;\nconst DefaultRotation = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity();\nconst DefaultScale = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.OneReadOnly;\nconst DefaultLoaderCameraParentScaleLh = new _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1, 1, 1);\n/**\n * Get the information necessary for enumerating a vertex buffer.\n * @param vertexBuffer the vertex buffer to enumerate\n * @param meshes the meshes that use the vertex buffer\n * @returns the information necessary to enumerate the vertex buffer\n */\nfunction GetVertexBufferInfo(vertexBuffer, meshes) {\n    const { byteOffset, byteStride, type, normalized } = vertexBuffer;\n    const componentCount = vertexBuffer.getSize();\n    const totalVertices = meshes.reduce((max, current) => {\n        return current.getTotalVertices() > max ? current.getTotalVertices() : max;\n    }, -Number.MAX_VALUE); // Get the max total vertices count, to ensure we capture the full range of vertex data used by the meshes.\n    const count = totalVertices * componentCount;\n    const kind = vertexBuffer.getKind();\n    return { byteOffset, byteStride, componentCount, type, count, normalized, totalVertices, kind };\n}\nfunction GetAccessorElementCount(accessorType) {\n    switch (accessorType) {\n        case \"MAT2\" /* AccessorType.MAT2 */:\n            return 4;\n        case \"MAT3\" /* AccessorType.MAT3 */:\n            return 9;\n        case \"MAT4\" /* AccessorType.MAT4 */:\n            return 16;\n        case \"SCALAR\" /* AccessorType.SCALAR */:\n            return 1;\n        case \"VEC2\" /* AccessorType.VEC2 */:\n            return 2;\n        case \"VEC3\" /* AccessorType.VEC3 */:\n            return 3;\n        case \"VEC4\" /* AccessorType.VEC4 */:\n            return 4;\n    }\n}\nfunction FloatsNeed16BitInteger(floatArray) {\n    return floatArray.some((value) => value >= 256);\n}\nfunction IsStandardVertexAttribute(type) {\n    switch (type) {\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.PositionKind:\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.NormalKind:\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.TangentKind:\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.ColorKind:\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.MatricesIndicesKind:\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.MatricesIndicesExtraKind:\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.MatricesWeightsKind:\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.MatricesWeightsExtraKind:\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.UVKind:\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.UV2Kind:\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.UV3Kind:\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.UV4Kind:\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.UV5Kind:\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.UV6Kind:\n            return true;\n    }\n    return false;\n}\nfunction GetAccessorType(kind, hasVertexColorAlpha) {\n    if (kind == _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.ColorKind) {\n        return hasVertexColorAlpha ? \"VEC4\" /* AccessorType.VEC4 */ : \"VEC3\" /* AccessorType.VEC3 */;\n    }\n    switch (kind) {\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.PositionKind:\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.NormalKind:\n            return \"VEC3\" /* AccessorType.VEC3 */;\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.TangentKind:\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.MatricesIndicesKind:\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.MatricesIndicesExtraKind:\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.MatricesWeightsKind:\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.MatricesWeightsExtraKind:\n            return \"VEC4\" /* AccessorType.VEC4 */;\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.UVKind:\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.UV2Kind:\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.UV3Kind:\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.UV4Kind:\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.UV5Kind:\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.UV6Kind:\n            return \"VEC2\" /* AccessorType.VEC2 */;\n    }\n    throw new Error(`Unknown kind ${kind}`);\n}\nfunction GetAttributeType(kind) {\n    switch (kind) {\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.PositionKind:\n            return \"POSITION\";\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.NormalKind:\n            return \"NORMAL\";\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.TangentKind:\n            return \"TANGENT\";\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.ColorKind:\n            return \"COLOR_0\";\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.UVKind:\n            return \"TEXCOORD_0\";\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.UV2Kind:\n            return \"TEXCOORD_1\";\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.UV3Kind:\n            return \"TEXCOORD_2\";\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.UV4Kind:\n            return \"TEXCOORD_3\";\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.UV5Kind:\n            return \"TEXCOORD_4\";\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.UV6Kind:\n            return \"TEXCOORD_5\";\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.MatricesIndicesKind:\n            return \"JOINTS_0\";\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.MatricesIndicesExtraKind:\n            return \"JOINTS_1\";\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.MatricesWeightsKind:\n            return \"WEIGHTS_0\";\n        case _babylonjs_core_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.MatricesWeightsExtraKind:\n            return \"WEIGHTS_1\";\n    }\n    throw new Error(`Unknown kind: ${kind}`);\n}\nfunction GetPrimitiveMode(fillMode) {\n    switch (fillMode) {\n        case _babylonjs_core_Materials_material_js__WEBPACK_IMPORTED_MODULE_2__.Material.TriangleFillMode:\n            return 4 /* MeshPrimitiveMode.TRIANGLES */;\n        case _babylonjs_core_Materials_material_js__WEBPACK_IMPORTED_MODULE_2__.Material.TriangleStripDrawMode:\n            return 5 /* MeshPrimitiveMode.TRIANGLE_STRIP */;\n        case _babylonjs_core_Materials_material_js__WEBPACK_IMPORTED_MODULE_2__.Material.TriangleFanDrawMode:\n            return 6 /* MeshPrimitiveMode.TRIANGLE_FAN */;\n        case _babylonjs_core_Materials_material_js__WEBPACK_IMPORTED_MODULE_2__.Material.PointListDrawMode:\n        case _babylonjs_core_Materials_material_js__WEBPACK_IMPORTED_MODULE_2__.Material.PointFillMode:\n            return 0 /* MeshPrimitiveMode.POINTS */;\n        case _babylonjs_core_Materials_material_js__WEBPACK_IMPORTED_MODULE_2__.Material.LineLoopDrawMode:\n            return 2 /* MeshPrimitiveMode.LINE_LOOP */;\n        case _babylonjs_core_Materials_material_js__WEBPACK_IMPORTED_MODULE_2__.Material.LineListDrawMode:\n            return 1 /* MeshPrimitiveMode.LINES */;\n        case _babylonjs_core_Materials_material_js__WEBPACK_IMPORTED_MODULE_2__.Material.LineStripDrawMode:\n            return 3 /* MeshPrimitiveMode.LINE_STRIP */;\n    }\n    throw new Error(`Unknown fill mode: ${fillMode}`);\n}\nfunction IsTriangleFillMode(fillMode) {\n    switch (fillMode) {\n        case _babylonjs_core_Materials_material_js__WEBPACK_IMPORTED_MODULE_2__.Material.TriangleFillMode:\n        case _babylonjs_core_Materials_material_js__WEBPACK_IMPORTED_MODULE_2__.Material.TriangleStripDrawMode:\n        case _babylonjs_core_Materials_material_js__WEBPACK_IMPORTED_MODULE_2__.Material.TriangleFanDrawMode:\n            return true;\n    }\n    return false;\n}\nfunction NormalizeTangent(tangent) {\n    const length = Math.sqrt(tangent.x * tangent.x + tangent.y * tangent.y + tangent.z * tangent.z);\n    if (length > 0) {\n        tangent.x /= length;\n        tangent.y /= length;\n        tangent.z /= length;\n    }\n}\nfunction ConvertToRightHandedPosition(value) {\n    value.x *= -1;\n    return value;\n}\n/** @internal */\nfunction ConvertToRightHandedTransformMatrix(matrix) {\n    _exportUtils_js__WEBPACK_IMPORTED_MODULE_8__.ConvertHandednessMatrix.invertToRef(_babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Matrix[0]).multiplyToRef(matrix, matrix).multiplyToRef(_exportUtils_js__WEBPACK_IMPORTED_MODULE_8__.ConvertHandednessMatrix, matrix);\n    return matrix;\n}\n/**\n * Converts, in-place, a left-handed quaternion to a right-handed quaternion via a change of basis.\n * @param value the unit quaternion to convert\n * @returns the converted quaternion\n */\nfunction ConvertToRightHandedRotation(value) {\n    /**\n     * This is the simplified version of the following equation:\n     *    q' = to_quaternion(M * to_matrix(q) * M^-1)\n     * where M is the conversion matrix `convertHandednessMatrix`,\n     * q is the input quaternion, and q' is the converted quaternion.\n     * Reference: https://d3cw3dd2w32x2b.cloudfront.net/wp-content/uploads/2015/01/matrix-to-quat.pdf\n     */\n    if (value.x * value.x + value.y * value.y > 0.5) {\n        const absX = Math.abs(value.x);\n        const absY = Math.abs(value.y);\n        if (absX > absY) {\n            const sign = Math.sign(value.x);\n            value.x = absX;\n            value.y *= -sign;\n            value.z *= -sign;\n            value.w *= sign;\n        }\n        else {\n            const sign = Math.sign(value.y);\n            value.x *= -sign;\n            value.y = absY;\n            value.z *= sign;\n            value.w *= -sign;\n        }\n    }\n    else {\n        const absZ = Math.abs(value.z);\n        const absW = Math.abs(value.w);\n        if (absZ > absW) {\n            const sign = Math.sign(value.z);\n            value.x *= -sign;\n            value.y *= sign;\n            value.z = absZ;\n            value.w *= -sign;\n        }\n        else {\n            const sign = Math.sign(value.w);\n            value.x *= sign;\n            value.y *= -sign;\n            value.z *= -sign;\n            value.w = absW;\n        }\n    }\n    return value;\n}\n/**\n * Pre-multiplies a 180-degree Y rotation to the quaternion, in order to match glTF's flipped forward direction for cameras.\n * @param rotation Target camera rotation.\n */\nfunction Rotate180Y(rotation) {\n    // Simplified from: rotation * (0, 1, 0, 0).\n    rotation.copyFromFloats(-rotation.z, rotation.w, rotation.x, -rotation.y);\n}\n/**\n * Collapses GLTF parent and node into a single node, ignoring scaling.\n * This is useful for removing nodes that were added by the GLTF importer.\n * @param node Original GLTF node (Light or Camera).\n * @param parentNode Target parent node.\n */\nfunction CollapseChildIntoParent(node, parentNode) {\n    const parentTranslation = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(parentNode.translation || [0, 0, 0], 0, _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[0]);\n    const parentRotation = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Quaternion.FromArrayToRef(parentNode.rotation || [0, 0, 0, 1], 0, _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Quaternion[0]);\n    const parentMatrix = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Matrix.ComposeToRef(DefaultScale, parentRotation, parentTranslation, _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Matrix[0]);\n    const translation = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(node.translation || [0, 0, 0], 0, _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[2]);\n    const rotation = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Quaternion.FromArrayToRef(node.rotation || [0, 0, 0, 1], 0, _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Quaternion[1]);\n    const matrix = _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Matrix.ComposeToRef(DefaultScale, rotation, translation, _babylonjs_core_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Matrix[1]);\n    parentMatrix.multiplyToRef(matrix, matrix);\n    matrix.decompose(undefined, parentRotation, parentTranslation);\n    if (parentTranslation.equalsWithEpsilon(DefaultTranslation, _babylonjs_core_Maths_math_constants_js__WEBPACK_IMPORTED_MODULE_7__.Epsilon)) {\n        delete parentNode.translation;\n    }\n    else {\n        parentNode.translation = parentTranslation.asArray();\n    }\n    if (parentRotation.equalsWithEpsilon(DefaultRotation, _babylonjs_core_Maths_math_constants_js__WEBPACK_IMPORTED_MODULE_7__.Epsilon)) {\n        delete parentNode.rotation;\n    }\n    else {\n        parentNode.rotation = parentRotation.asArray();\n    }\n    if (parentNode.scale) {\n        delete parentNode.scale;\n    }\n}\n/**\n * Checks whether a camera or light node is candidate for collapsing with its parent node.\n * This is useful for roundtrips, as the glTF Importer parents a new node to\n * lights and cameras to store their original transformation information.\n * @param babylonNode Babylon light or camera node.\n * @param parentBabylonNode Target Babylon parent node.\n * @returns True if the two nodes can be merged, false otherwise.\n */\nfunction IsChildCollapsible(babylonNode, parentBabylonNode) {\n    if (!(parentBabylonNode instanceof _babylonjs_core_Meshes_transformNode_js__WEBPACK_IMPORTED_MODULE_3__.TransformNode)) {\n        return false;\n    }\n    // Verify child is the only descendant\n    const isOnlyDescendant = parentBabylonNode.getChildren().length === 1 && babylonNode.getChildren().length === 0 && babylonNode.parent === parentBabylonNode;\n    if (!isOnlyDescendant) {\n        return false;\n    }\n    // Verify parent has the expected scaling, determined by the node type and scene's coordinate system.\n    const scene = babylonNode.getScene();\n    const expectedScale = babylonNode instanceof _babylonjs_core_Cameras_targetCamera_js__WEBPACK_IMPORTED_MODULE_6__.TargetCamera && !scene.useRightHandedSystem ? DefaultLoaderCameraParentScaleLh : DefaultScale;\n    if (!parentBabylonNode.scaling.equalsWithEpsilon(expectedScale, _babylonjs_core_Maths_math_constants_js__WEBPACK_IMPORTED_MODULE_7__.Epsilon)) {\n        _babylonjs_core_Misc_logger_js__WEBPACK_IMPORTED_MODULE_5__.Logger.Warn(`Cannot collapse node ${babylonNode.name} into parent node ${parentBabylonNode.name} with modified scaling.`);\n        return false;\n    }\n    return true;\n}\n/**\n * Converts an IndicesArray into either a Uint32Array or Uint16Array.\n * If the `start` and `count` parameters specify a subset of the array, a new view is created.\n * If the input is a number[], the data is copied into a new buffer.\n * @param indices input array to be converted\n * @param start starting index\n * @param count number of indices\n * @param is32Bits whether the output should be Uint32Array (true) or Uint16Array (false) when indices is an `Array`\n * @returns a Uint32Array or Uint16Array\n * @internal\n */\nfunction IndicesArrayToTypedSubarray(indices, start, count, is32Bits) {\n    let processedIndices = indices;\n    if (start !== 0 || count !== indices.length) {\n        processedIndices = Array.isArray(indices) ? indices.slice(start, start + count) : indices.subarray(start, start + count);\n    }\n    // If Int32Array, cast the indices (which should all be positive) to Uint32Array\n    if (processedIndices instanceof Int32Array) {\n        return new Uint32Array(processedIndices.buffer, processedIndices.byteOffset, processedIndices.length);\n    }\n    if (Array.isArray(processedIndices)) {\n        return is32Bits ? new Uint32Array(processedIndices) : new Uint16Array(processedIndices);\n    }\n    return processedIndices;\n}\nfunction DataArrayToUint8Array(data) {\n    if (data instanceof Array) {\n        const floatData = new Float32Array(data);\n        return new Uint8Array(floatData.buffer, floatData.byteOffset, floatData.byteLength);\n    }\n    return ArrayBuffer.isView(data) ? new Uint8Array(data.buffer, data.byteOffset, data.byteLength) : new Uint8Array(data);\n}\nfunction GetMinMax(data, vertexBuffer, start, count) {\n    const { byteOffset, byteStride, type, normalized } = vertexBuffer;\n    const size = vertexBuffer.getSize();\n    const min = new Array(size).fill(Infinity);\n    const max = new Array(size).fill(-Infinity);\n    (0,_babylonjs_core_Buffers_bufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.EnumerateFloatValues)(data, byteOffset + start * byteStride, byteStride, size, type, count * size, normalized, (values) => {\n        for (let i = 0; i < size; i++) {\n            min[i] = Math.min(min[i], values[i]);\n            max[i] = Math.max(max[i], values[i]);\n        }\n    });\n    return { min, max };\n}\n/**\n * Removes, in-place, object properties which have the same value as the default value.\n * Useful for avoiding unnecessary properties in the glTF JSON.\n * @param object the object to omit default values from\n * @param defaultValues a partial object with default values\n * @returns object with default values omitted\n */\nfunction OmitDefaultValues(object, defaultValues) {\n    for (const [key, value] of Object.entries(object)) {\n        const defaultValue = defaultValues[key];\n        if ((Array.isArray(value) && Array.isArray(defaultValue) && AreArraysEqual(value, defaultValue)) || value === defaultValue) {\n            delete object[key];\n        }\n    }\n    return object;\n}\nfunction AreArraysEqual(array1, array2) {\n    return array1.length === array2.length && array1.every((val, i) => val === array2[i]);\n}\n//# sourceMappingURL=glTFUtilities.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/serializers/glTF/2.0/glTFUtilities.js?\n}");

/***/ }

}]);